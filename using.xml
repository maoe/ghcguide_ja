<?xml version="1.0" encoding="UTF-8"?>
<chapter id="using-ghc">
  <title>GHCを使う</title>

  <indexterm><primary>GHC, using</primary></indexterm>
  <indexterm><primary>using GHC</primary></indexterm>

  <sect1>
    <title>オプション概観</title>
    
    <para>GHCの振る舞いは<firstterm>オプション</firstterm>で制御される。歴史的な理由から、これはコマンド行フラグとか引数とも呼ばれる。オプションを指定する方法は次の三つである。</para>

    <sect2>
      <title>コマンド行引数</title>
      
      <indexterm><primary>structure, command-line</primary></indexterm>
      <indexterm><primary>command-line</primary><secondary>arguments</secondary></indexterm>
      <indexterm><primary>arguments</primary><secondary>command-line</secondary></indexterm>
      
      <para>GHCを起動するときは次のような形をとる。</para>

<screen>
ghc [argument...]
</screen>

      <para>コマンド行引数はオプションかファイル名のどちらかである。</para>

      <para>コマンド行オプションは<literal>-</literal>ではじまる。これをひとまとめにすることはできない。つまり、<option>-vO</option>は<option>-v -O</option>とは異なる。オプションがファイル名より先に置かれる必要はない。例えば、<literal>ghc *.o -o foo</literal>のようにである。まず全てのオプションが処理され、全てのファイルに適用される。そのため、例えば<literal>ghc -c -O1 Foo.hs -O2 Bar.hs</literal>として<filename>Foo.hs</filename>と<filename>Bar.hs</filename>に異なる最適化水準を適用するということはできない。</para>
    </sect2>

    <sect2 id="source-file-options">
      <title>ソースファイル中のコマンド行オプション</title>
    
      <indexterm><primary>source-file options</primary></indexterm>

      <para>ソースファイルと、それが必要とするコマンド行オプションの結合をとても強くした方が便利なことがある。例えば、あるHaskellソースファイルがGHC拡張を使うなら、それは常に<option>-fglasgow-exts</option>オプション付きでコンパイルされなければならない。<filename>Makefile</filename>でファイルごとのオプションの一覧を管理する代わりに、<literal>OPTIONS_GHC</literal>プラグマを使ってソースファイルに直接これを書き込むこともできる。<indexterm><primary>OPTIONS_GHC pragma</primary></indexterm></para>

<programlisting>
{-# OPTIONS_GHC -fglasgow-exts #-}
module X where
...
</programlisting>
      
      <para><literal>OPTIONS_GHC</literal>プラグマはソースファイルの先頭でしか探されない。探されるのは、<literal>OPTIONS_GHC</literal>を含まない(文芸コメントでなく、空でない)最初の行までである。複数の<literal>OPTIONS_GHC</literal>プラグマも認識される。<literal>OPTIONS_GHC</literal>プラグマより前の行または同じ行にコメントを置いてはならない。</para>

      <para>ソースファイル中のオプションはコマンドシェルには渡されず、コンパイラが内部的に管理するコマンド行引数の配列に加えられるだけだということに注意せよ。そのため、<literal>OPTIONS_GHC</literal>の中でワイルドカードなどを使おうとすると猛烈にがっかりすることになるだろう。</para>

      <para>注意: OPTIONS_GHCの内容はコマンド行オプションの前に連結されるので、OPTIONS_GHCでの設定をコマンド行から変更することができる。</para>

      <para>Makefileの内容を全てソースファイルに移すのは推奨されないが、場合によっては<literal>OPTIONS_GHC</literal>プラグマを使うのが「正しい方法」である。(<option>-keep-hc-file-too</option>を使っていて、モジュールにOPTIONフラグがあるなら、生成された.hcファイルにOPTIONS_GHCが置かれる)</para>
    </sect2>

    <sect2>
      <title>GHCiからオプションを設定する</title>

      <para>GHCiの中から<literal>:set</literal>コマンドを使ってオプションを変更することもできる。詳しくは<xref linkend="ghci-set"/>を見よ。</para>
    </sect2>
  </sect1>
    
  <sect1 id="static-dynamic-flags">
    <title>静的オプション、動的オプション、モード指定オプション</title>
    <indexterm><primary>static</primary><secondary>options</secondary>
    </indexterm>
    <indexterm><primary>dynamic</primary><secondary>options</secondary>
    </indexterm>
    <indexterm><primary>mode</primary><secondary>options</secondary>
    </indexterm>

    <para>GHCのコマンド行引数は<firstterm>静的オプション</firstterm>か、<firstterm>動的オプション</firstterm>か、<firstterm>モード指定オプション</firstterm>に分類される。</para>

    <variablelist>
      <varlistentry>
        <term>モード指定フラグ</term>
	<listitem>
          <para>例えば<option>--make</option>や<option>-E</option>がこれである。モード指定フラグはコマンド行から一つだけ指定しても良い。利用可能なモードの一覧は<xref linkend="modes"/>にある。</para>
	</listitem>
      </varlistentry>
      <varlistentry>
        <term>動的フラグ</term>
	<listitem>
          <para>モード指定フラグ以外の大部分のフラグはこれに分類される。動的なフラグはコマンド行で使っても良いし、ソースファイルの<literal>GHC_OPTIONS</literal>プラグマ<!-- 訳注　OPTIONS_GHCの誤り -->で使っても良いし、GHCiで<literal>:set</literal>を使って設定しても良い。</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>静的フラグ</term>
	<listitem>
	  <para>「静的な」フラグも少しある。これは、コマンド行からのみ使うことができ、一回のGHC/GHCiの実行を通して有効である。</para>
	</listitem>
      </varlistentry>
    </variablelist>
    
    <para>フラグの早見表(<xref linkend="flag-reference"/>)にはそれぞれのフラグがどれに分類されるか記されている。</para>
    <para>静的であるが、GHCiの<literal>:set</literal>コマンドで設定できるフラグも少しながらある。これは表中では&ldquo;static/<literal>:set</literal>&rdquo;と表記される。</para>
  </sect1>

  <sect1 id="file-suffixes">
    <title>意味を持つファイル接尾辞</title>

    <indexterm><primary>suffixes, file</primary></indexterm>
    <indexterm><primary>file suffixes for GHC</primary></indexterm>

    <para>「意味を持つ」接尾辞(例えば、<filename>.lhs</filename>や<filename>.o</filename>)を持つファイルは、それにしたがって「適切な」方法で処理される。</para>

    <variablelist>

      <varlistentry>
	<term><filename>.hs</filename></term>
	<listitem>
          <para>Haskellモジュール。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <filename>.lhs</filename>
          <indexterm><primary><literal>lhs</literal> suffix</primary></indexterm>
	</term>
	<listitem>
          <para>「文芸的Haskell」モジュール。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><filename>.hi</filename></term>
	<listitem>
          <para>おそらくはコンパイラによって生成された、Haskellインタフェースファイル。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><filename>.hc</filename></term>
	<listitem>
          <para>Haskellコンパイラによって生成された中間のCファイル。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><filename>.c</filename></term>
	<listitem>
          <para>Haskellコンパイラによって生成されたもの以外のCファイル。</para>
	</listitem>
      </varlistentry>
      
      <varlistentry>
	<term><filename>.s</filename></term>
	<listitem>
          <para>アセンブリ言語のソースファイル。ふつうはコンパイラによって生成される。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><filename>.o</filename></term>
	<listitem>
          <para>アセンブラによって生成されたオブジェクトファイル。</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>これ以外の接尾辞を持つファイル(または接尾辞を持たないファイル)はリンカに直接渡される。</para>

  </sect1>

  <sect1 id="modes">
    <title>実行モード</title>

    <para>GHCの振る舞いはまずモード指定フラグによって制御される。これらのフラグのうちただ一つだけを使うことができるが、コマンド行において最初のオプションである必要はない。以下のモードが利用できる。</para>

    <variablelist>
      <varlistentry>
	<term>
	  <cmdsynopsis><command>ghc</command>
	    <arg choice='plain'>&ndash;&ndash;interactive</arg>
	  </cmdsynopsis>
          <indexterm><primary>interactive mode</primary></indexterm>
          <indexterm><primary>ghci</primary></indexterm>
	</term>
	<listitem>
          <para>対話的モード。<command>ghci</command>としても使える。対話的モードは<xref linkend="ghci"/>で詳しく説明されている。</para>
	</listitem>
      </varlistentry>
      
      <varlistentry>
	<term>
	  <cmdsynopsis><command>ghc</command>
	    <arg choice='plain'>&ndash;&ndash;make</arg>
	  </cmdsynopsis>
          <indexterm><primary>make mode</primary></indexterm>
          <indexterm><primary><option>&ndash;&ndash;make</option></primary></indexterm>
	</term>
	<listitem>
          <para>このモードでは、GHCは複数のモジュールから成るHaskellのプログラムを、依存性を解析しながら自動的にビルドする。単純なHaskellプログラムなら、これは<command>make</command>を使うのに比べてずっと簡単で、しかも速い。makeモードは<xref linkend="make-mode"/>で説明されている。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
	  <cmdsynopsis><command>ghc</command>
	    <arg choice='plain'>&ndash;e</arg> <arg choice='plain'><replaceable>expr</replaceable></arg>
          </cmdsynopsis>
          <indexterm><primary>eval mode</primary></indexterm>
	</term>
	<listitem>
          <para>式を評価するモード。これは対話的モードによく似ているが、評価する式は一つだけで、コマンド行から与えられる。さらなる詳細は<xref linkend="eval-mode"/>を見よ。</para>
	</listitem>
      </varlistentry>
      
      <varlistentry>
	<term>
          <cmdsynopsis>
	    <command>ghc</command>
	    <group>
	      <arg>-E</arg>
	      <arg>-C</arg>
	      <arg>-S</arg>
	      <arg>-c</arg>
	    </group>
	  </cmdsynopsis>
	  <indexterm><primary><option>-E</option></primary></indexterm>
	  <indexterm><primary><option>-C</option></primary></indexterm>
	  <indexterm><primary><option>-S</option></primary></indexterm>
	  <indexterm><primary><option>-c</option></primary></indexterm>
        </term>
	<listitem>
          <para>これは伝統的な一括処理コンパイラモードである。このモードでは、GHCは一度に一つのソースファイルをコンパイルするか、オブジェクトファイルをリンクして実行可能ファイルを作る。コマンドラインでモードが指定されなかった場合も、このモードが使われる。このときは、指定されたファイルをコンパイルして、さらにリンクしてプログラムを作る、という動作になる。<xref linkend="options-order"/>を見よ。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <cmdsynopsis>
            <command>ghc</command>
	    <arg choice='plain'>&ndash;M</arg>
          </cmdsynopsis>
          <indexterm><primary>dependency-generation mode</primary></indexterm>
        </term>
	<listitem>
          <para>依存性生成モード。このモードでは、GHCは<literal>Makefile</literal>で使うのに適した依存性情報を生成する。<xref linkend="sec-makefile-dependencies"/>を見よ。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <cmdsynopsis>
            <command>ghc</command>
	    <arg choice='plain'>&ndash;&ndash;mk-dll</arg>
          </cmdsynopsis>
	  <indexterm><primary>dependency-generation mode</primary></indexterm>
        </term>
	<listitem>
          <para>DLL作成モード。(Windowsのみ)<xref linkend="win32-dlls-create"/>を見よ。</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <sect2 id="make-mode">
      <title><command>ghc</command> <option>&ndash;&ndash;make</option>を使う</title>
      <indexterm><primary><option>&ndash;&ndash;make</option></primary></indexterm>
      <indexterm><primary>separate compilation</primary></indexterm>
      
      <para><option>&ndash;&ndash;make</option>オプションが指定されると、GHCは複数のモジュールから成るプログラムをビルドする。このとき、GHCは根となる単一のモジュール(ふつうは<literal>Main</literal>)から出発して依存性を追跡する。例えば、<literal>Main</literal>モジュールが<filename>Main.hs</filename>というファイルに置かれているとすると、次のようにしてこのプログラムをコンパイル・リンクすることができる。</para>

<screen>
ghc &ndash;&ndash;make Main.hs
</screen>

      <para>コマンド行はソースファイル名やモジュール名をいくつ含んでいても良い。それらを初期モジュールとしてインポートを追いかけることで、GHCはプログラムの全てのモジュールを見つけ出す。次に、古くなったモジュールの再コンパイルが試みられ、最後に、もし<literal>Main</literal>モジュールがあるなら、プログラムはリンクされて実行可能形式になる。</para>

      <para>伝統的な<literal>Makefile</literal>に比べて、<literal>ghc &ndash;&ndash;make</literal>を使うことの利点は、以下のようなことである。</para>

      <itemizedlist>
	<listitem>
          <para>コンパイルのためにGHCを再起動する必要がないので、コンパイル間で情報をキャッシュすることができる。複数のモジュールから成るプログラムを<literal>ghc &ndash;&ndash;make</literal>でコンパイルすると、個々のソースファイルに対して<literal>ghc</literal>を走らせたときに比べて二倍も速いことがある。</para>
	</listitem>
	<listitem>
          <para><literal>Makefile</literal>を書く必要がない。</para>
          <indexterm><primary><literal>Makefile</literal>s</primary><secondary>avoiding</secondary></indexterm>
	</listitem>
	<listitem>
          <para>起動されるたびにGHCが依存関係を再計算するので、ソースとの整合性が失われることがない。</para>
	</listitem>
      </itemizedlist>
      
      <para>この章でこれ以降に解説されるコマンド行オプションは全て<option>&ndash;&ndash;make</option>とともに用いることができる。ただし、コマンド行から与えられたオプションは全てのソースファイルに適用されるので、単一のソースファイルにのみ適用したいオプションについては<literal>OPTIONS_GHC</literal>プラグマ(<xref linkend="source-file-options"/>を見よ)を使う必要があることに注意せよ。</para>

      <para>プログラムを追加のオブジェクト(例えばCの補助コード)にリンクする必要があるなら、そのオブジェクトファイルをコマンド行で与えれば、GHCは実行ファイルをリンクするときにそれを含める。</para>
      
      <para>GHCはソースファイルがあるときしか依存関係を追跡できないので、ソースコードのないモジュールがプログラムに含まれていると、たとえオブジェクトファイルとインタフェースファイルがあったとしても、GHCは文句を言うことに注意せよ。パッケージのモジュールはこの規則の例外で、ソースファイルがあってもなくても良い。</para>

      <para>プログラムのソースファイルが全て同じディレクトリにある必要はない。<option>-i</option>オプションを使ってディレクトリを探索パスに加えることができる。(<xref linkend="search-path"/>を見よ)</para>
    </sect2>
  
    <sect2 id="eval-mode">
      <title>式評価モード</title>

      <para>式を評価するモード。これは対話的モードによく似ているが、評価する式は一つだけで、コマンド行から<option>-e</option>オプションの引数として与えられる。</para>

<screen>
ghc -e <replaceable>expr</replaceable>
</screen>

      <para>コマンド行からHaskellソースファイルを指定することもでき、それらは対話的モードと全く同じようにロードされる。指定された式はロードされたモジュールの文脈で評価される。</para>

      <para>例えば、<literal>Main</literal>というモジュールを含むHaskellプログラムをロードして走らせるには、次のようにすれば良い。</para>

<screen>
ghc -e Main.main Main.hs
</screen>
      
      <para>また、このモードを、単に式を<literal>Prelude</literal>の文脈で評価するのに使うこともできる。</para>

<screen>
$ ghc -e "interact (unlines.map reverse.lines)"
hello
olleh
</screen>
    </sect2>

    <sect2 id="options-order">
      <title>一括処理コンパイラモード</title>
      
      <para><emphasis>一括処理</emphasis>モードでは、GHCはコマンド行で与えられた一つ以上のソースファイルをコンパイルする。</para>
      
      <para>コンパイルが、複数ある段階のどこから始まるかは、それぞれの入力ファイルの接尾辞によって決定される。また、どこで終わるかは、フラグによって決定される。もしこれに関連するフラグが与えられなかったときは、リンクまでの全ての段階を実行する。次の表はこれをまとめたものである。</para>
      
      <informaltable>
	<tgroup cols="4">
	  <colspec align="left"/>
	  <colspec align="left"/>
	  <colspec align="left"/>
	  <colspec align="left"/>
	  
	  <thead>
	    <row>
	      <entry>コンパイルシステムの段階</entry>
	      <entry>ここから開始する接尾辞</entry>
	      <entry>ここまでで終了することを指示するフラグ</entry>
	      <entry>出力ファイル(の接尾辞)</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>文芸形式プリプロセッサ</entry>
	      <entry><literal>.lhs</literal></entry>
	      <entry>-</entry>
	      <entry><literal>.hs</literal></entry>
	    </row>
	    
	    <row>
	      <entry>Cプリプロセッサ(省略可能)</entry>
	      <entry><literal>.hs</literal> (<option>-cpp</option>が与えられたとき)</entry>
	      <entry><option>-E</option></entry>
	      <entry><literal>.hspp</literal></entry>
	    </row>
	    
	    <row>
	      <entry>Haskellコンパイラ</entry>
	      <entry><literal>.hs</literal></entry>
	      <entry><option>-C</option>, <option>-S</option></entry>
	      <entry><literal>.hc</literal>, <literal>.s</literal></entry>
	    </row>
	    
	    <row>
	      <entry>Cコンパイラ(省略可能)</entry>
	      <entry><literal>.hc</literal> or <literal>.c</literal></entry>
	      <entry><option>-S</option></entry>
	      <entry><literal>.s</literal></entry>
	    </row>
	    
	    <row>
	      <entry>アセンブラ</entry>
	      <entry><literal>.s</literal></entry>
	      <entry><option>-c</option></entry>
	      <entry><literal>.o</literal></entry>
	    </row>
	    
	    <row>
	      <entry>リンカ</entry>
	      <entry><replaceable>other</replaceable></entry>
	      <entry>-</entry>
	      <entry><filename>a.out</filename></entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
      
      <indexterm><primary><option>-C</option></primary></indexterm>
      <indexterm><primary><option>-E</option></primary></indexterm>
      <indexterm><primary><option>-S</option></primary></indexterm>
      <indexterm><primary><option>-c</option></primary></indexterm>
      
      <para>そういうわけで、次のようなものがよくある起動のされかたである。</para>

<screen>
ghc -c Foo.hs</screen>
      
      <para>これはHaskellソースファイル<filename>Foo.hs</filename>をコンパイルしてオブジェクトファイル<filename>Foo.o</filename>を生成する。</para>

      <para>注意: Haskellコンパイラが実際に出力するのが何かはネイティブコード生成器<indexterm><primary>native-code generator</primary></indexterm>が使われている(アセンブリ言語を出力する)かそうでない(Cを出力する)かによる。詳しくは、<xref linkend="options-codegen"/>を見よ。</para>

      <para>注意: Cプリプロセスは省略可能であり、<option>-cpp</option><indexterm><primary><option>-cpp</option></primary></indexterm>フラグによって有効になる。詳しくは<xref linkend="c-pre-processor"/>を見よ。</para>
      
      <para>注意: <option>-E</option><indexterm><primary>-E option</primary></indexterm>オプションはコンパイラをプリプロセス段階まで走らせ、結果をファイルに出力する。これは以前の振る舞い(ファイルを標準出力に表示)とは異なることに注意。</para>

      <sect3 id="overriding-suffixes">
        <title>ファイルに対するデフォルトの振る舞いを上書きする</title>

        <para>上記のように、GHCがファイルを処理する方法はその接尾辞による。これは<option>-x</option>オプションを使って変更できる。</para>

	<variablelist>
	  <varlistentry>
	    <term><option>-x</option> <replaceable>suffix</replaceable>
	    	      <indexterm><primary><option>-x</option></primary>
	      </indexterm></term>
	      <listitem>
                <para>コマンドラインにおいてこれに続く全てのファイルを<replaceable>suffix</replaceable>という接尾辞を持つかのように扱う。例えば、<literal>M.my-hs</literal>というファイルにあるHaskellモジュールをコンパイルするには、<literal>ghc -c -x hs M.my-hs</literal>とすれば良い。</para>
	      </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>

    </sect2>
  </sect1>

  <sect1 id="options-help">
    <title>ヘルプと多弁さに関するオプション</title>

    <indexterm><primary>help options</primary></indexterm>
    <indexterm><primary>verbosity options</primary></indexterm>

    <variablelist>
      <varlistentry>
	<term>
          <option>&ndash;&ndash;help</option>
          <indexterm><primary><option>&ndash;&ndash;help</option></primary></indexterm>
        </term>
	<term>
          <option>-?</option>
          <indexterm><primary><option>-?</option></primary></indexterm>
        </term>
	<listitem>
          <para>使いかたに関する長いメッセージを標準出力に吐いて、終了する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <option>-n</option>
          <indexterm><primary><option>-n</option></primary></indexterm>
        </term>
	<listitem>
          <para>ドライランを行う。すなわち、GHCは通常のようにコンパイルの手順を追うが、実際に外部コマンドを走らせることはしない。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <option>-v</option>
          <indexterm><primary><option>-v</option></primary></indexterm>
        </term>
	<listitem>
          <para><option>-v</option>はGHCを<emphasis>多弁に</emphasis>する。GHCはバージョン番号を報告し、コンパイルシステムの段階ごとに、どのようにそれを起動したか(標準エラー出力に)表示する。さらに、大部分のコンパイル段階に対しても<option>-v</option>を渡し、渡されたものはバージョン番号(ほかの情報もあるかもしれない)を報告する。</para>

          <para>心よりのお願いとして、バグを報告するときは<option>-v</option>オプションを使って頂きたい！我々は常に、あなたが正しいものを正しい順序で走らせているということを最初に確かめたいのである。</para>
	</listitem>
      </varlistentry>
	
      <varlistentry>
	<term>
          <option>-v</option><replaceable>n</replaceable>
          <indexterm><primary><option>-v</option></primary></indexterm>
        </term>
	<listitem>
          <para>より正確にコンパイラの多弁さを制御するために、<option>-v</option>は省略可能な数値引数をとる。<option>-v</option>を単独で指定するのは<option>-v3</option>と同じで、そのほかの水準は以下のような意味を持っている。</para>
	  
	  <variablelist>
	    <varlistentry>
	      <term><option>-v0</option></term>
	      <listitem>
                <para>本質的でないメッセージを表示しない。(これがデフォルトである)</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><option>-v1</option></term>
	      <listitem>
                <para>最小限の多弁さ。コンパイル一回毎に一行を表示する。(<option>&ndash;&ndash;make</option>または<option>&ndash;&ndash;interactive</option>が有効のときはこれがデフォルト)</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><option>-v2</option></term>
	      <listitem>
                <para>コンパイル段階が実行されるときに、その名前を印字する。(<option>-dshow-passes</option>と同等)</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><option>-v3</option></term>
	      <listitem>
                <para><option>-v2</option>と同じであるが、各コンパイル段階について完全なコマンド行(あれば)を印字する。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><option>-v4</option></term>
	      <listitem>
                <para><option>-v3</option>と同じだが、各コンパイル段階が終わった後にその段階での中間形式でプログラムを表示する。(プリプロセスの結果とC/アセンブリファイルを除く)</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>
      </varlistentry>
      
      <varlistentry>
	<term>
          <option>-V</option>
          <indexterm><primary><option>-V</option></primary></indexterm>
        </term>
	<term>
          <option>&ndash;&ndash;version</option>
          <indexterm><primary><option>&ndash;&ndash;version</option></primary></indexterm>
        </term>
	<listitem>
          <para>GHCのバージョン番号を含む一行の文字列を印字する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <option>&ndash;&ndash;numeric-version</option>
          <indexterm><primary><option>&ndash;&ndash;numeric-version</option></primary></indexterm>
        </term>
	<listitem>
          <para>GHCの数値的なバージョン番号のみを印字する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <option>&ndash;&ndash;print-libdir</option>
          <indexterm><primary><option>&ndash;&ndash;print-libdir</option></primary></indexterm>
        </term>
	<listitem>
          <para>GHCのライブラリディレクトリのパスを表示する。これはGHCのライブラリファイル、インタフェースファイル、およびインクルードファイルが置かれているディレクトリツリーの最上位である。(Unixではふつう<literal>/usr/local/lib/ghc-5.04</literal>のようなところである)これはパッケージ設定ファイルにおける<literal>libdir</literal><indexterm><primary><literal>libdir</literal></primary></indexterm>の値である。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-ferror-spans</option>
          <indexterm><primary><option>-ferror-spans</option></primary>
	  </indexterm>
        </term>
	<listitem>
          <para>エラーメッセージに関連する構文要素がソースで占める位置を完全に出力するようにする。通常、GHCは構文要素の先頭の位置しか報告しない。</para>

	  <para>例えば、次のものは、</para>

<screen>test.hs:3:6: parse error on input `where'</screen>

	  <para>以下のようになる。</para>

<screen>test296.hs:3:6-10: parse error on input `where'</screen>

	  <para>また、複数行に渡る区間もあり得る。</para>

<screen>test.hs:(5,4)-(6,7):
    Conflicting definitions for `a'
    Bound at: test.hs:5:4
              test.hs:6:7
    In the binding group for: a, b, a</screen>

          <para>行番号は一からはじまるが、カラム番号は零からはじまることに注意。これは既存の慣習に合わせたものである。(つまり、Emacsがこの方法を使っているということ)</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><option>-H</option><replaceable>size</replaceable>
        <indexterm><primary><option>-H</option></primary></indexterm>
        </term>
        <listitem>
          <para>ヒープの最小サイズを<replaceable>size</replaceable>にする。これは<literal>-RTS&nbsp;-H<replaceable>size</replaceable></literal>と同等である。<xref linkend="rts-options-gc"/>を見よ。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><option>-Rghc-timing</option>
        <indexterm><primary><option>-Rghc-timing</option></primary></indexterm>
        </term>
        <listitem>
          <para>GHCの実行に要した時間についての統計情報の一行要約を表示する。このオプションは<literal>+RTS&nbsp;-tstderr</literal>と同等である。<xref linkend="rts-options-gc"/>を見よ。</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect1>

  &separate;

  <sect1 id="options-sanity">
    <title>警告と正気度チェックのためのオプション</title>

    <indexterm><primary>sanity-checking options</primary></indexterm>
    <indexterm><primary>warnings</primary></indexterm>


    <para>GHCでは、いくつかのオプションを使って、生成する致命的でないエラーメッセージ(警告ともいう)の種類を選ぶことができる。デフォルトでは、一般にプログラムのバグを示していることが多い警告が有効になっている。これは<option>-fwarn-overlapping-patterns</option>、<option>-fwarn-deprecations</option>、<option>-fwarn-duplicate-exports</option>、<option>-fwarn-missing-fields</option>、<option>-fwarn-missing-methods</option>である。以下のフラグは標準的な警告の「詰め合わせ」を簡単に選択するためのものである。</para>
    <variablelist>

      <varlistentry>
	<term><option>-W</option>:</term>
	<listitem>
	  <indexterm><primary>-W option</primary></indexterm>
          <para>標準的な警告に加えて、 <option>-fwarn-incomplete-patterns</option>、<option>-fwarn-unused-matches</option>、<option>-fwarn-unused-imports</option>、<option>-fwarn-unused-binds</option>を提供する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-w</option>:</term>
	<listitem>
	  <indexterm><primary><option>-w</option></primary></indexterm>
          <para>全ての警告を、標準的なものも含めて、無効にする。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-Wall</option>:</term>
	<listitem>
	  <indexterm><primary><option>-Wall</option></primary></indexterm>
          <para>全ての警告オプションを有効にする。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-Werror</option>:</term>
	<listitem>
	  <indexterm><primary><option>-Werror</option></primary></indexterm>
          <para>全ての警告を致命的なエラーにする。一括コンパイルのときに警告を見逃さないようにするのに便利である。</para>
	</listitem>
      </varlistentry>

    </variablelist>

    <para>以下は全ての警告オプションの説明である。なんらかの警告を無効にしたいときは、単に対応する<option>-fno-warn-...</option>をコマンド行から与えれば良い。</para>

    <variablelist>

      <varlistentry>
	<term><option>-fwarn-deprecations</option>:</term>
	<listitem>
	  <indexterm><primary><option>-fwarn-deprecations</option></primary>
	  </indexterm>
	  <indexterm><primary>deprecations</primary></indexterm>
          <para>非推奨の関数や型が使われたときに警告する。何かを非推奨と宣言するにはプラグマを使う。<xref linkend="deprecated-pragma"/>を見よ。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-duplicate-exports</option>:</term>
	<listitem>
	  <indexterm><primary><option>-fwarn-duplicate-exports</option></primary></indexterm>
	  <indexterm><primary>duplicate exports, warning</primary></indexterm>
	  <indexterm><primary>export lists, duplicates</primary></indexterm>

          <para>エクスポートリスト中で重複している要素について警告する。大きなエクスポートリストを管理しているとき、そこから何かを削除したのに相変わらずそれがエクスポートされ続ける、という事態を回避するのに有用である。</para>

          <para>このオプションはデフォルトで有効である。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-hi-shadowing</option>:</term>
	<listitem>
	  <indexterm><primary><option>-fwarn-hi-shadowing</option></primary></indexterm>
	  <indexterm><primary>shadowing</primary>
	    <secondary>interface files</secondary></indexterm>

          <para>現在のディレクトリにあるモジュールやインタフェースファイルが、ライブラリディレクトリなどにある同名のものを隠しているときに警告する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-incomplete-patterns</option>:</term>
	<listitem>
	  <indexterm><primary><option>-fwarn-incomplete-patterns</option></primary></indexterm>
	  <indexterm><primary>incomplete patterns, warning</primary></indexterm>
	  <indexterm><primary>patterns, incomplete</primary></indexterm>

          <para>不完全なパターンについても同様で、<!-- 訳注 意図不明 -->下記の関数<function>g</function>は非空のリストに適用されたときに失敗する。<option>-fwarn-incomplete-patterns</option>が有効なときは、これに関する警告が出力される。</para>

<programlisting>
g [] = 2
</programlisting>

          <para>このオプションは少々うるさいことがあり、また常にプログラムのバグを示しているわけでもないので、デフォルトでは有効になっていない。しかし、関数を書くときは全ての場合に対応するのが一般には良い習慣とされている。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-incomplete-record-updates</option>:</term>
	<listitem>
	  <indexterm><primary><option>-fwarn-incomplete-record-updates</option></primary></indexterm>
	  <indexterm><primary>incomplete record updates, warning</primary></indexterm>
	  <indexterm><primary>record updates, incomplete</primary></indexterm>

          <para>下記の関数<function>f</function>は<literal>Bar</literal>に適用されたときに失敗する。<option>-fwarn-incomplete-record-updates</option>が有効だと、このような場合に警告が発せられる。</para>

<programlisting>
data Foo = Foo { x :: Int }
         | Bar

f :: Foo -> Foo
f foo = foo { x = 6 }
</programlisting>

          <para>このオプションはとてもうるさいことがあり、プログラムのバグを示していないことがしばしばあるので、デフォルトでは有効にされていない。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <option>-fwarn-missing-fields</option>:
	  <indexterm><primary><option>-fwarn-missing-fields</option></primary></indexterm>
	  <indexterm><primary>missing fields, warning</primary></indexterm>
	  <indexterm><primary>fields, missing</primary></indexterm>
        </term>
	<listitem>

          <para>このオプションはデフォルトで有効であり、ラベル付きフィールドを使った構築が完全でない、つまり一つ以上のフィールドについて初期化子を欠いているときに警告する。これはエラーではないが(省略されたフィールドはボトムで初期化される)、しばしばプログラムの誤りを示している。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-missing-methods</option>:</term>
	<listitem>
	  <indexterm><primary><option>-fwarn-missing-methods</option></primary></indexterm>
	  <indexterm><primary>missing methods, warning</primary></indexterm>
	  <indexterm><primary>methods, missing</primary></indexterm>

          <para>このオプションはデフォルトで有効であり、インスタンス宣言が一つ以上のメソッドを欠いていて、しかもそのメソッドのデフォルト定義が対応するクラス宣言にないときに警告する。</para>
          <para>この警告はメソッド名がアンダースコアで始まっているときには抑止される。これが便利なのは例えば次のような場合である。
	    <programlisting>
	      class C a where
	        _simpleFn :: a -> String
	        complexFn :: a -> a -> String
	        complexFn x y = ... _simpleFn ...
	      </programlisting>
            意図は、(a) クラスの利用者は専ら<literal>complexFn</literal>を呼び、<literal>_simpleFn</literal>を呼ぶことはない。(b) インスタンス宣言では<literal>complexFn</literal>か<literal>_simpleFn</literal>のどちらかを定義すれば良い。というものである。
	    </para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-missing-signatures</option>:</term>
	<listitem>
	  <indexterm><primary><option>-fwarn-missing-signatures</option></primary></indexterm>
	  <indexterm><primary>type signatures, missing</primary></indexterm>

          <para>全てのトップレベルの関数・値に型シグネチャがあることをGHCに確認させたいなら、<option>-fwarn-missing-signatures</option>オプションを使うと良い。これはデフォルトで無効である。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-name-shadowing</option>:</term>
	<listitem>
	  <indexterm><primary><option>-fwarn-name-shadowing</option></primary></indexterm>
	  <indexterm><primary>shadowing, warning</primary></indexterm>
	  
          <para>このオプションが有効だと、内側のスコープの値と同名の外側のスコープの値があるとき、つまり内側の値が外側のものを隠すときに警告する。これはミスタイプが原因の発見しがたいバグを捕らえることがある。例えば、<literal>let x = ... x ... in</literal>という意図的でない環状の定義が考えられる。</para>

          <para>結果として、このオプションは環状の再帰的定義に対しても文句をいう。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-orphans</option>:</term>
	<listitem>
	  <indexterm><primary><option>-fwarn-orphans</option></primary></indexterm>
	  <indexterm><primary>orphan instances, warning</primary></indexterm>
	  <indexterm><primary>orphan rules, warning</primary></indexterm>
	  
          <para>このオプションが有効なら、モジュールに「孤立した」インスタンス宣言や書き換え規則があるときに警告する。インスタンス宣言が孤立インスタンス宣言なのは、クラスおよびインスタンス化される型の両方と別のモジュールに置かれているときである。規則が孤立規則なのは、それが別のモジュールで宣言された関数についての規則であるときである。「孤立した」ものを含むモジュールは孤立モジュールと呼ばれる。</para>
          <para>問題は、孤立モジュールについては、そのインスタンスや規則が意味を持つ場合に備えて、他に理由がなくても、GHCが積極的にインタフェースファイルを読まなければいけないということである。特に理由がないなら、孤立モジュールを避けること。(訳注: 孤立モジュールについて詳しくは<xref linkend="orphan-modules"/>を参照)</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <option>-fwarn-overlapping-patterns</option>:
          <indexterm><primary><option>-fwarn-overlapping-patterns</option></primary></indexterm>
          <indexterm><primary>overlapping patterns, warning</primary></indexterm>
          <indexterm><primary>patterns, overlapping</primary></indexterm>
        </term>
	<listitem>
          <para>デフォルトで、コンパイラはパターンが重複しているときに警告する。つまり、以下のような場合である。</para>

<programlisting>
f :: String -&#62; Int
f []     = 0
f (_:xs) = 1
f "2"    = 2
</programlisting>

          <para>この場合、<function>f</function>の最後のパターン照合には決して到達しない。二番目のパターンがこれに重複しているからである。冗長なパターンはプログラマの誤りであることが、そうでない場合よりも多い。そのため、このオプションはデフォルトで有効である。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-simple-patterns</option>:</term>
	<listitem>
	  <indexterm><primary><option>-fwarn-simple-patterns</option></primary>
	  </indexterm>
          <para>失敗する可能性のあるラムダ束縛されたパターンについて警告する。例えば、<literal>\(x:xs)->...</literal>のような場合である。通常、これらは<option>-fwarn-incomplete-patterns</option>でいう不完全なパターンとはみなされない。</para>
          <para>「ラムダ束縛されたパターン」には単一のパターンがある全ての場所、例えばリストの内包表記やdo記法が含まれる。これらの場合ではパターン照合の失敗は合法であり、フィルタリング(リスト内包表記)またはモナドの<literal>fail</literal>操作(モナド)を引き起こす。例えば、
	    <programlisting>
	      f :: [Maybe a] -> [a]
	      f xs = [y | Just y &lt;- xs]
	      </programlisting>
            <option>-fwarn-simple-patterns</option>を有効にすると、このような、おそらく無実の場合についても警告を出す。これがこのフラグがデフォルトで無効にされている理由である。</para>
          <para><literal>deriving( Read )</literal>機構はパターン照合を使ったモナディックなコードを生成するので、コンパイラ生成のコードに関する誤解を招く警告を目にするかも知れない。(これはまず間違いなく悪いことであるが、修正は厄介である)</para>

	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-type-defaults</option>:</term>
	<listitem>
	  <indexterm><primary><option>-fwarn-type-defaults</option></primary></indexterm>
	  <indexterm><primary>defaulting mechanism, warning</primary></indexterm>
          <para>数値型に対するデフォルト化機構が発動したときに警告・通知する。これは、あるデフォルトを前提としたコードを別のデフォルトの下のコードに変換するときに便利である。例えば、<constant>1</constant>という値に特に制約がないとき、Haskell 1.4の「デフォルトのデフォルト」は型<literal>Int</literal>を与えるが、Haskell 98ではこれは<literal>Integer</literal>である。これは実行時性能と挙動に影響を与える可能性があるので、通知されると便利である。</para>

	  <para>この警告はデフォルトで無効である。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-unused-binds</option>:</term>
	<listitem>
	  <indexterm><primary><option>-fwarn-unused-binds</option></primary></indexterm>
	  <indexterm><primary>unused binds, warning</primary></indexterm>
	  <indexterm><primary>binds, unused</primary></indexterm>
          <para>未使用の関数定義(および局所的な束縛)を報告する。トップレベルの関数については、その束縛がエクスポートされていない場合のみ警告される。</para>
          <para>ある定義が「使われている」のは、(a)エクスポートされている、または(b)他の使われている関数定義の右辺で言及されている、または(c)定義される関数がアンダースコアで始まっている、ときである。最後の条件のおかげで、未使用の束縛に対する警告を選択的に抑制することができる。</para>
          <para>ある変数が他の未使用の束縛の右辺に現れても、その変数は未使用だと報告される点に注意。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-unused-imports</option>:</term>
	<listitem>
	  <indexterm><primary><option>-fwarn-unused-imports</option></primary></indexterm>
	  <indexterm><primary>unused imports, warning</primary></indexterm>
	  <indexterm><primary>imports, unused</primary></indexterm>

          <para>明示的にインポートされながら使われていないモジュールを全て報告する。ただし、<literal>import M()</literal>の形のインポートは報告されない。これはインスタンス宣言(Haskellでは無名である)をインポートするための有用な決まり文句だからである。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-unused-matches</option>:</term>
	<listitem>
	  <indexterm><primary><option>-fwarn-unused-matches</option></primary></indexterm>
	  <indexterm><primary>unused matches, warning</primary></indexterm>
	  <indexterm><primary>matches, unused</primary></indexterm>

          <para>パターン照合で発生する未使用の変数を全て報告する。これには、単一の変数から成るパターンも含む。例えば、<literal>f x y = []</literal>に対しては<varname>x</varname>と<varname>y</varname>が未使用だと報告する。この警告は変数名がアンダースコアからはじまる場合は抑制される。つまり、
	    <programlisting>
	       f _x = True
	    </programlisting>
            のような場合である。
          </para>
	</listitem>
      </varlistentry>

    </variablelist>

    <para>あたたが本当に心配性なら、<option>-dcore-lint</option>オプション<indexterm><primary><option>-dcore-lint</option></primary></indexterm>を使うと良い。これは、GHC内部でのパス内正気度チェックを有効にする。(これがチェックするのはGHCの正気であり、あなたの正気ではない)</para>

  </sect1>

  &packages;

  <sect1 id="options-optimise">
    <title>最適化(コードの改善)</title>

    <indexterm><primary>optimisation</primary></indexterm>
    <indexterm><primary>improvement, code</primary></indexterm>

    <para><option>-O*</option>オプションは便利な最適化フラグの「詰め合わせ」を指定するのに使う。後で説明される<option>-f*</option>オプションは<emphasis>個々の</emphasis>最適化を有効/無効にするのに使う。<option>-m*</option>は<emphasis>機械固有の</emphasis>最適化を有効/無効にするのに使う。</para>

    <sect2 id="optimise-pkgs">
      <title><option>-O*</option>: 便利な最適化フラグの「詰め合わせ」。</title>

      <para>GHCが生成するコードの質に影響を与えるオプションは<emphasis>大量に</emphasis>ある。大抵の人には一般的な目標しかない。つまり、「素早くコンパイルすること」であるとか「電光石火のように走るプログラムを生成すること」などである。以下に示す最適化の「詰め合わせ」を指定すれば(あるいは指定しないことを選べば)十分なはずである。</para>

      <para>注意点として、高い最適化水準では多くのモジュール間最適化が行われ、何かを変更したときにどの程度再コンパイルが必要かに影響を与える。これは開発中に非最適化を貫くことの理由の一つである。</para>

      <variablelist>

	<varlistentry>
	  <term>
            <option>-O*</option>が指定されないとき:
            <indexterm><primary>-O* not specified</primary></indexterm>
          </term>
	  <listitem>
            <para>「なるべく速くコンパイルしてほしい。できたコードの品質についてはうるさくいわない」という意味にとられる。例えば、<command>ghc -c Foo.hs</command>のような場合である。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
            <option>-O0</option>:
            <indexterm><primary><option>-O0</option></primary></indexterm>
          </term>
	  <listitem>
            <para>「全ての最適化を無効にせよ」という意味であり、<option>-O</option>が指定されていないかのような状態に戻す。<option>-O0</option>は、例えば<command>make</command>が既に<option>-O</option>をコマンド行に挿入しているときに便利である。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
            <option>-O</option>または<option>-O1</option>:
            <indexterm><primary>-O option</primary></indexterm>
            <indexterm><primary>-O1 option</primary></indexterm>
            <indexterm><primary>optimise</primary><secondary>normally</secondary></indexterm>
          </term>
	  <listitem>
            <para>「高品質のコードをそれほど時間を掛けずに生成せよ」という意味である。例えば、<command>ghc -c -O Main.lhs</command>のように使われる。</para>

            <para>現在、<option>-O</option>を指定すると<option>-fvia-C</option>も有効になる。これは将来変わるかもしれない。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
            <option>-O2</option>:
            <indexterm><primary>-O2 option</primary></indexterm>
            <indexterm><primary>optimise</primary><secondary>aggressively</secondary></indexterm>
          </term>
	  <listitem>
            <para>「危険でない全ての最適化を適用せよ。コンパイルに非常に時間が掛かっても構わない」という意味である。</para>

            <para>避けられる「危険」な最適化とは、運が悪いときに実行時間・空間を<emphasis>悪化</emphasis>させるおそれのあるものである。通常これらは個々に設定される。</para>

            <para>現時点では、<option>-O2</option>が<option>-O</option>よりも良いコードを生成することは考えにくい。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
            <option>-Ofile &lt;file&gt;</option>:
            <indexterm><primary>-Ofile &lt;file&gt; option</primary></indexterm>
            <indexterm><primary>optimising, customised</primary></indexterm>
          </term>
	  <listitem>
            <para>(注意: GHC 4.x以降サポートされていない。もしこれに興味があるなら尋ねて欲しい。)</para>
	    
            <para><emphasis>厳密に</emphasis>どのオプションが使われるかについて<emphasis>絶対的な</emphasis>制御をしたいと考える者(例えば、場合によっては、コンパイラ屋とか。 笑)向けの機能として、オプションの組み合わせをファイルに置いておき、それを<option>-Ofile</option>で読み込むことができる。</para>

            <para>そのファイルでは、コメントは<literal>&num;</literal>から行末まで、という奴である。空行及び大部分の空白文字は無視される。</para>

            <para>あなたが困っていて、<option>-Ofile</option>の例が欲しいなら、その旨知らせて欲しい。</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>我々は日々の作業では<option>-O*</option>を使わない。それなりの速度が必要なときは<option>-O</option>を使う。例えば、何かを計測するときなどである。「とにかくハイクオリティがいいお( ＾ω＾) 時間とか気にしないお！CPU稼働率100％でも構わないお！」というあなたには、<option>-O2 -fvia-C</option>オプションをどうぞ。ガリガリ音を立てるPCを後にして、コーヒーを100万回飲みに行こう。(コーヒーブレイクするってレベルじゃねぇぞ！)</para>

      <para><option>-O</option>(など)が何を「実際に意味している」かを知るもっとも簡単な方法は、<option>-v</option>を付けて走らせ、驚きのあまり後ずさることである。</para>
    </sect2>

    <sect2 id="options-f">
      <title><option>-f*</option>: プラットフォーム非依存のフラグ</title>

      <indexterm><primary>-f* options (GHC)</primary></indexterm>
      <indexterm><primary>-fno-* options (GHC)</primary></indexterm>

      <para>これらのフラグは個々の最適化を有効・無効にする。これらは通常、上記の<option>-O</option>系のオプションを介して設定され、したがって、どれも明示的に指定する必要はないはずである。(実際、そうすると予期せぬ結果が訪れるかもしれない)。しかし、一・二の興味が湧く例はあるかもしれない。</para>

      <variablelist>
	<varlistentry>
	  <term><option>-fexcess-precision</option>:</term>
	  <listitem>
	    <indexterm><primary><option>-fexcess-precision</option></primary></indexterm>
            <para>このオプションが与えられると、中間の浮動小数点数が最終的な型よりも<emphasis>大きな</emphasis>精度/範囲をもつことが許される。一般にはこれは良いことだが、<literal>Float</literal>/<literal>Double</literal>の正確な精度/範囲に依存したプログラムがあるかもしれず、そのようなプログラムはこのオプションなしでコンパイルせねばならない。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-fignore-asserts</option>:</term>
	  <listitem>
	    <indexterm><primary><option>-fignore-asserts</option></primary></indexterm>
            <para>ソースコード中で<literal>Exception.assert</literal>関数が使われていても無視する。(言い替えると、<literal>Exception.assert p e</literal>を<literal>e</literal>に書き換える。<xref linkend="sec-assertions"/>を見よ)。このフラグは<option>-O</option>が指定されていると有効になる。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
            <option>-fno-cse</option>
            <indexterm><primary><option>-fno-cse</option></primary></indexterm>
          </term>
	  <listitem>
            <para>共通部分式削除の最適化を無効にする。共通化されてほしくない<literal>unsafePerformIO</literal>を使った式があるときに便利だろう。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
            <option>-fno-strictness</option>
            <indexterm><primary><option>-fno-strictness</option></primary></indexterm>
          </term>
	  <listitem>
            <para>正格性解析器を無効にする。正格性解析器はあまりに多くのマシンサイクルを消費することがある。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
            <option>-fno-full-laziness</option>
            <indexterm><primary><option>-fno-full-laziness</option></primary></indexterm>
          </term>
	  <listitem>
            <para>完全遅延(full laziness)最適化(let-floatingとしても知られる)を無効にする。完全遅延は共有を促進するが、これはmemory residency(訳注: 意味不明)を増やすことにつながる。</para>

            <para>注意: GHCは完全遅延を完全には実装していない。最適化が有効で、<option>-fno-full-laziness</option>が与えられなかったとき、共有を促進するある種の最適化が実行される。例えば繰り返し実行される計算をループから抽出する、といったことである。これらは完全遅延の実装で行われるのと同じ変換だが、GHCは常に完全遅延を適用するとは限らないという違いがあるので、これに頼らないこと。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
            <option>-fno-state-hack</option>
            <indexterm><primary><option>-fno-state-hack</option></primary></indexterm>
          </term>
	  <listitem>
            <para><literal>State#</literal>トークンを引数として持っているラムダは全て単一進入(訳注: single entry。クロージャが一回しかenterされない(呼ばれない)こと)であるとみなし、したがってその内容をインライン化しても良いとみなされる、という「stateハック」を無効にする。このハックはIOとSTモナドを使うコードの性能を向上させることがあるが、共有が阻害される危険も伴っている。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
            <option>-funbox-strict-fields</option>:
	    <indexterm><primary><option>-funbox-strict-fields</option></primary></indexterm>
	    <indexterm><primary>strict constructor fields</primary></indexterm>
	    <indexterm><primary>constructor fields, strict</primary></indexterm>
          </term>
	  <listitem>
            <para>このオプションは正格と印の付けられた(つまり「!」)構築子フィールドを可能なら全て非ボックス化、つまりアンパックする。これは全ての正格な構築子フィールドに<literal>UNPACK</literal>プラグマを付けるのと同等である。(<xref linkend="unpack-pragma"/>を見よ)</para>

            <para>このオプションは少々大槌を振り回す感じがある。場合によっては状況を悪化させかねない。<literal>UNPACK</literal>を使ってフィールドを選択的に非ボックス化する方が良いかもしれない。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
            <option>-funfolding-update-in-place&lt;n&gt;</option>
            <indexterm><primary><option>-funfolding-update-in-place</option></primary></indexterm>
          </term>
	  <listitem>
            <para>ある実験的な「最適化」を有効にする。これを有効にすると、サンクの文脈では、構築子を返す関数を少しだけ積極的にインライン化するようになる。
<programlisting>
   x = plusInt a b
</programlisting>
            plusIntをインライン化すれば、サンク「x」について、その場更新(update-in-place)を使う機会が得られるかもしれない。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
            <option>-funfolding-creation-threshold&lt;n&gt;</option>:
	    <indexterm><primary><option>-funfolding-creation-threshold</option></primary></indexterm>
	    <indexterm><primary>inlining, controlling</primary></indexterm>
	    <indexterm><primary>unfolding, controlling</primary></indexterm>
          </term>
	  <listitem>
            <para>(デフォルト: 45)関数の展開候補(unfolding)に許される最大の大きさを定める。(展開候補には、それが呼び出し点で展開されたときの「コード膨張」のコストを反映した「大きさ」が与えられる。大きい関数ほど大きなコストを持つ)</para>

            <para>これによる影響は、(a)これより大きい物は(INLINEプラグマがない限り)決してインライン展開されない (b)これより大きい物は決してインタフェースファイルに吐かれることはない、という点である。</para>

            <para>この数値を増やしても、結果としてコードが速くなるというよりは単にコンパイル時間が長くなる公算が高い。次のオプションの方が便利である。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-funfolding-use-threshold&lt;n&gt;</option>:</term>
	  <listitem>
	    <indexterm><primary><option>-funfolding-use-threshold</option></primary></indexterm>
	    <indexterm><primary>inlining, controlling</primary></indexterm>
	    <indexterm><primary>unfolding, controlling</primary></indexterm>

            <para>(デフォルト: 8)これは展開にあたっての魔法のカットオフ値である。これより小さい関数定義は呼び出し元に展開され、これより大きい物は展開されない。関数の大きさは、式の実際の大きさに、適用される割引を加味したものである。(<option>-funfolding-con-discount</option>を見よ<!-- 訳注: このオプションはもはや存在しない -->)</para>
	  </listitem>
	</varlistentry>
      </variablelist>

    </sect2>
    
  </sect1>
  
  &phases;  
  
  <sect1 id="sec-using-concurrent">
    <title>Concurrent Haskellを使う</title>
    <indexterm><primary>Concurrent Haskell</primary><secondary>using</secondary></indexterm>

    <para>GHCはデフォルトでConcurrent Haskellをサポートしていて、特別なオプションが必要だったリ、特別な方法でコンパイルされたライブラリが必要だったりはしない。Concurrent Haskellのサポートライブラリにアクセスするには、単に<ulink url="../libraries/base/Control-Concurrent.html"><literal>Control.Concurrent</literal></ulink>(訳注: 未訳。<ulink url="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html">web上の最新版</ulink>)をインポートすれば良い。Concurrent Haskellについてのさらなる情報はこのモジュールの付属文書にある。</para>

    <para>以下のRTSオプションがConcurrent Haskellプログラムの振る舞いに影響する。<indexterm><primary>RTS options, concurrent</primary></indexterm></para>

    <variablelist>
      <varlistentry>
	<term><option>-C<replaceable>s</replaceable></option></term>
	<listitem>
	  <para><indexterm><primary><option>-C<replaceable>s</replaceable></option></primary><secondary>RTS option</secondary></indexterm>コンテキストスイッチの間隔を<replaceable>s</replaceable>秒に設定する。コンテキストスイッチは、時間切れの後の最初のヒープブロック確保の時点で発生する。(ヒープブロックの確保は確保4k毎に起こる)。<option>-C0</option>または<option>-C</option>を使うと、コンテキストスイッチは可能な限り頻繁に(ヒープブロックの確保の度に)発生するようになる。デフォルトでは、コンテキストスイッチは20ms毎に発生する。</para>
	</listitem>
      </varlistentry>
    </variablelist>
  </sect1>

  <sect1 id="sec-using-smp">
    <title>SMP並列計算を使う</title>
    <indexterm><primary>parallelism</primary>
    </indexterm>
    <indexterm><primary>SMP</primary>
    </indexterm>

    <para>GHCはSMP(対称型マルチプロセッサ)上でのHaskellプログラムの並列実行をサポートしている。</para>

    <para><emphasis>並行性(concurrency)</emphasis>と<emphasis>並列性(parallelism)</emphasis>の間には明確な区別がある。並列性は、専ら、複数のプロセッサを同時に使うことでプログラムを<emphasis>速く</emphasis>することについてである。一方、並行性は抽象化の一手段である。具体的には、複数の非同期のイベントに対応せねばならないプログラムを構築するための便利な方法である。</para>

    <para>とはいうものの、この二つの用語は確かに関連している。複数のCPUを使うことで、複数の並行スレッドを並列に実行することができるようになる。GHCのSMP並列計算サポートはまさにこれを行う。しかし、並行性を利用しないプログラムにおいて、並列計算によってパフォーマンスを改善することも、また可能である。この節では、GHCを使って並列プログラムをコンパイル・実行する方法を解説し、<xref linkend="lang-parallel"/>では並列性に影響する言語機能を説明する。</para>
    
    <sect2 id="parallel-options">
      <title>SMP並列計算を有効にするオプション</title>

      <para>複数のCPUを利用するには、プログラムが<option>-threaded</option>オプション付きでリンクされていなればならない。(<xref linkend="options-linker"/>を見よ)。その上で、複数のCPU上でプログラムを走らせるには、RTSの<option>-N</option>オプションを使う。</para>
      
      <variablelist>
	<varlistentry>
	  <term><option>-N<replaceable>x</replaceable></option></term>
	  <listitem>
	    <para><indexterm><primary><option>-N<replaceable>x</replaceable></option></primary><secondary>RTS option</secondary></indexterm>プログラムの実行中、同時に<replaceable>x</replaceable>個のスレッドを使う。通常、<replaceable>x</replaceable>は機械のCPUコア数と一致するべきである。プログラムが開始した後にこの値を変更する方法は(今のところ)ない。</para>

            <para>例えば、デュアルコアの機械ではおそらく<literal>+RTS -N2 -RTS</literal>を使うことになるだろう。</para>

	    <para>hyperthreadingコアの数を含めるべきかどうかは未解決の問題である。遠慮なく実験して結果を知らせてほしい。</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
      
    <sect2>
      <title>SMP並列計算を使うにあたってのヒント</title>

      <para>プログラムを実行するときに<literal>-sstderr</literal>というRTSオプションを加えると、時間統計情報を見ることができる。これを使って、使うCPUの数を増やしたことでプログラムが速くなったかどうかを確認できる。ユーザ(user)時間が消費(elapsed)時間よりも大きいなら、プログラムは単一のCPUよりも多くを使ったことになる。比較のために<literal>-N</literal>オプションなしでも走らせてみると良いだろう。</para>

      <para>GHCの並列計算サポートは新しく、実験的である。プログラムは速くなるかもしれないし、遅くなるかもしれない。どちらにしても、我々に報告を頂けるなら興味深く聞くだろう。</para>
      
      <para>現在の実装の重大な制限の一つは、ガベッジコレクタがまだ単一スレッドであって、GCの作動中には全ての実行が停止しなければならないことである。これは並列プログラムの重大なボトルネックになり得る。特にプログラムが多くのGCを行うときはそうである。こういう事態に出会ったら、GCの設定をいじる(<xref linkend="rts-options-gc"/>)ことでGCのコストを減らそうとしてみるのが良いだろう。ヒープや確保領域を大きくすることから始めてみると良い。</para>
    </sect2>
  </sect1>

  <sect1 id="options-platform">
    <title>プラットフォーム固有のフラグ</title>

    <indexterm><primary>-m* options</primary></indexterm>
    <indexterm><primary>platform-specific options</primary></indexterm>
    <indexterm><primary>machine-specific options</primary></indexterm>

    <para>フラグには特定のプラットフォームでしか意味をなさないものがある。</para>

    <variablelist>

      <varlistentry>
	<term><option>-monly-[32]-regs</option>:</term>
	<listitem>
          <para>(iX86の機械)<indexterm><primary>-monly-N-regs option (iX86 only)</primary></indexterm>GHCはパフォーマンスのために四つのレジスタをGCCから「盗もうと」する。これは大抵うまく行く。しかし、ある種のモジュールでは、四つのレジスタを盗まれた状態でGCCがコンパイルしていると、おそらく次のように言ってクラッシュする。

<screen>
Foo.hc:533: fixed or forbidden register was spilled.
This may be due to a compiler bug or to impossible asm
statements or clauses.
</screen>

          <option>-monly-N-regs</option>でレジスタをいくつか返してやると良い。まず「3」を試し、次に「2」を試す。「2」でもうまく行かないなら、バグとして報告して頂きたい。</para>
	</listitem>
      </varlistentry>
    </variablelist>

  </sect1>

&runtime;

<sect1 id="ext-core">
  <title>外部コアファイルを生成・コンパイルする</title>

  <indexterm><primary>intermediate code generation</primary></indexterm>

  <para>GHCは、コンパイルの副作用として、最適化済み中間コード(「コア」形式と呼ぶ)をファイルに出力することができる。コアファイル(接尾辞は<filename>.hcr</filename>)は、GHC以外のバックエンドツールで読んだり処理したりすることができる。コア形式は<ulink url="http://www.haskell.org/ghc/docs/papers/core.ps.gz"><citetitle>An External Representation for the GHC Core Language</citetitle></ulink>で形式的に解説されており、コアファイルを操作するツールのサンプル(Haskell製)はGHCのソース配布ディレクトリ<literal>/fptools/ghc/utils/ext-core</literal>から入手できる。<literal>.hcr</literal>ファイルの形式はデバッグのために生成されるコア出力(<xref linkend="options-debugging"/>)とは<emphasis>異なる</emphasis>(似てはいるが)ことに注意。</para>

  <para>コア形式は注釈(note)を最初からサポートしている。注釈を加えるには、ソースコード中で<literal>CORE</literal>プラグマ(<xref linkend="pragmas"/>を見よ)を使えば良い。</para>

    <variablelist>

  	<varlistentry>
	  <term>
            <option>-fext-core</option>
            <indexterm><primary><option>-fext-core</option></primary></indexterm>
          </term>
	  <listitem>
            <para><literal>.hcr</literal>ファイルを生成する。</para>
	  </listitem>
	</varlistentry>

    </variablelist>

<para>また、GHCは外部コアをソースとして読み込むこともできる。これには、単に<literal>.hcr</literal>ファイルを<literal>.hs</literal>や<literal>.lhs</literal>のHaskellソースの代わりにコマンド行から与えれば良い。現状の問題点として、このとき<literal>-fglasgow-exts</literal>フラグも与えなければならない。これは、通常のHaskell 98でも、外部コアに翻訳されると、ランク2の型などを使うようになるからである。</para>
</sect1>

&debug;
&flags;

</chapter>

<!-- Emacs stuff:
     ;;; Local Variables: ***
     ;;; mode: xml ***
     ;;; sgml-parent-document: ("users_guide.xml" "book" "chapter") ***
     ;;; End: ***
 -->
