<?xml version="1.0" encoding="UTF-8"?>
<chapter id="ghci">
  <title>GHCiを使う</title>
  <indexterm><primary>GHCi</primary></indexterm>
  <indexterm><primary>interpreter</primary><see>GHCi</see></indexterm>
  <indexterm><primary>interactive</primary><see>GHCi</see></indexterm>
  
  <para>GHCi<footnote><para>「i」はinteractiveのiである</para></footnote>はGHCの対話環境であり、Haskellの式を対話的に評価したりプログラムを解釈実行したりできる。もしあなたが<ulink url="http://www.haskell.org/hugs/">Hugs</ulink><indexterm><primary>Hugs</primary></indexterm>に慣れ親しんでいるなら、GHCiの扱いにもすぐに慣れるだろう。しかしながら、GHCiはコンパイル済みコードをロードすることができ、また、GHCが提供する言語拡張の全て<footnote><para>ただし、現在のところ、<literal>foreign export</literal>を除く</para></footnote>をサポートする。</para>
  <indexterm><primary>FFI</primary><secondary>GHCi support</secondary></indexterm>
  <indexterm><primary>Foreign Function Interface</primary><secondary>GHCi support</secondary></indexterm>

  <sect1>
    <title>GHCiの紹介</title>

    <para>GHCiセッションの例を見ていくことから始めよう。GHCiは<literal>ghci</literal>コマンドで起動することができる。</para>

<screen>
$ ghci
   ___         ___ _
  / _ \ /\  /\/ __(_)
 / /_\// /_/ / /  | |      GHC Interactive, version 6.6, for Haskell 98.
/ /_\\/ __  / /___| |      http://www.haskell.org/ghc/
\____/\/ /_/\____/|_|      Type :? for help.

Loading package base ... linking ... done.
Prelude> 
</screen>

    <para>GHCiがプレリュードと標準ライブラリをロードするのに少し時間が掛かるかもしれない。その後、プロンプトが表示される。指示にしたがって<literal>:?</literal>と打ち込むと、次が得られる。(訳注：以下には和訳を示す)</para>

<screen>
 プロンプトから使えるコマンド:

   &lt;stmt&gt;                      &lt;stmt&gt;を評価/実行する
   :add &lt;filename&gt; ...         現在のターゲットにモジュールを追加する
   :browse [*]&lt;module&gt;         &lt;module&gt;で定義されている名前を表示する
   :cd &lt;dir&gt;                   ディレクトリを&lt;dir&gt;に変更する
   :def &lt;cmd&gt; &lt;expr&gt;           :&lt;cmd&gt;というコマンドを定義する
   :edit &lt;file&gt;                ファイルを編集する
   :edit                       直近のモジュールを編集する
   :help, :?                   このコマンド一覧を表示する
   :info [&lt;name&gt; ...]          指定された名前についての情報を表示する
   :load &lt;filename&gt; ...        モジュールと、その依存関係をロードする
   :module [+/-] [*]&lt;mod&gt; ...  式を評価する上での文脈を設定する
   :main [&lt;arguments&gt; ...]     main関数を指定された引数で実行する
   :reload                     現在のモジュール群をリロードする

   :set &lt;option&gt; ...           オプションを有効にする
   :set args &lt;arg&gt; ...         System.getArgsによって返される引数を設定する
   :set prog &lt;progname&gt;        System.getProgNameによって返される値を設定する
   :set prompt &lt;prompt&gt;        GHCiの使うコマンドプロンプトを設定する
   :set editor &lt;cmd&gt;        :editで使われるコマンドを設定する

   :show modules               現在ロードされているモジュールを表示する
   :show bindings              プロンプトでなされた束縛を表示する

   :ctags [&lt;file&gt;]             Viのタグファイルを作る(デフォルト: "tags")
   :etags [&lt;file&gt;]             Emacsのタグファイルを作る(デフォルト: "TAGS")
   :type &lt;expr&gt;                &lt;expr&gt;の型を表示する
   :kind &lt;type&gt;                &lt;type&gt;の類を表示する
   :undef &lt;cmd&gt;                ユーザー定義コマンド:&lt;cmd&gt;を未定義にする
   :unset &lt;option&gt; ...         オプションを無効にする
   :quit                       GHCiを抜ける
   :!&lt;command&gt;                 シェルのコマンド&lt;command&gt;を実行する

 ':set'と':unset'で使えるオプション:

    +r            評価のたびに毎回トップレベルの式を復元する
    +s            評価のたびに時間/メモリの統計情報を印字する
    +t            評価の後に型を印字する
    -&lt;flags&gt;      GHCコマンド行フラグの大部分はここでもセットできる
                         (例えば、-v2、-fglasgow-extsなど)
</screen>

    <para>これらのコマンドの大部分はこれから説明する。Hugsの利用者へ: 多くのことがHugsと同じように動作するので、すぐに使えるようになるはずである。</para>

    <para>プロンプトでは、Haskellの式を入力することができる。</para>
    <indexterm><primary>prompt</primary><secondary>GHCi</secondary>
  </indexterm>

<screen>
Prelude> 1+2
3
Prelude> let x = 42 in x / 9
4.666666666666667
Prelude> 
</screen>

    <para>GHCiは行全体を一つの式だと解釈し、それを評価する。式は複数の行に渡っていてはいけない。エンターキーが押されると、GHCiは即座にそれを評価しようとする。</para>
  </sect1>

  <sect1>
    <title>ソースファイルをロードする</title>

    <para>次のようなHaskellソースコードが<filename>Main.hs</filename>というファイルに置かれているとしよう。</para>

<programlisting>
main = print (fac 20)

fac 0 = 1
fac n = n * fac (n-1)
</programlisting>

    <para><filename>Main.hs</filename>はどこでも好きなところに保存することができるが、カレントディレクトリ<footnote><para>GHCiをシェルから起動したのなら、GHCiのカレントディレクトリはシェルのそれと同じである。GHCiをWindowsの「スタート」メニューから起動したなら、カレントディレクトリはおそらく<filename>C:\Documents and Settings\<replaceable>user name</replaceable></filename>あたりになる。</para></footnote>以外の場所に保存した場合、GHCiでディレクトリを正しく変更する必要がある。</para>

<screen>
Prelude> :cd <replaceable>dir</replaceable>
</screen>

    <para>ここで、<replaceable>dir</replaceable>は<filename>Main.hs</filename>を保存したディレクトリ(あるいはフォルダ)である。</para>

    <para>HaskellのソースファイルをGHCiにロードするには、<literal>:load</literal>コマンドを使う。</para>
    <indexterm><primary><literal>:load</literal></primary></indexterm>

<screen>
Prelude> :load Main
Compiling Main             ( Main.hs, interpreted )
Ok, modules loaded: Main.
*Main>
</screen>

    <para>GHCiは<literal>Main</literal>モジュールをロードし、プロンプトが「<literal>*Main></literal>」に変わった。これは、プロンプトに入力される式を評価するのに使われる文脈が、今ロードしたばかりの<literal>Main</literal>モジュールになったことを示すためのものである(<literal>*</literal>が何を意味するかについては<xref linkend="ghci-scope"/>で説明する)。つまり、これで<filename>Main.hs</filename>で定義された関数を含む式を入力できるようになったということである。</para>

<screen>
*Main> fac 17
355687428096000
</screen>

    <para>複数のモジュールからなるプログラムをロードするのも同様に簡単である。「最上位の」モジュールの名前を<literal>:load</literal>コマンドに指定すれば良い(ヒント: <literal>:load</literal>は<literal>:l</literal>に短縮できる)。最上位のモジュールはふつう<literal>Main</literal>であるが、必ずしもそうである必要はない。GHCiは最上位のモジュールから直接・間接に必要とされているモジュールを見付け、それらを依存関係の順にロードする。</para>

    <sect2 id="ghci-modules-filenames">
      <title>モジュールとファイル名</title>
      <indexterm><primary>modules</primary><secondary>and filenames</secondary></indexterm>
      <indexterm><primary>filenames</primary><secondary>of modules</secondary></indexterm>
      
      <para>GHCは<replaceable>M</replaceable>というモジュールがどのファイルにあるかをどのようにして知るのだろうか。GHCiは、<literal><replaceable>M</replaceable>.hs</literal>または<literal><replaceable>M</replaceable>.lhs</literal>というファイルを探すのである。したがって、大部分のモジュールでは、モジュール名とファイル名は一致しなければならない。一致しなかった場合、GHCiはモジュールを見つけ出すことができない。</para>

      <para>この規則には一つの例外がある。<literal>:load</literal>を使ってプログラムをロードするとき、あるいは<literal>ghci</literal>を起動するとき、モジュール名ではなくファイル名を指定することができる。そのファイルはもし存在するならロードされ、どんなモジュールを含んでいても構わない。これは、複数の<literal>Main</literal>モジュールが一つのディレクトリにあって、全てを<filename>Main.hs</filename>とは呼べないときに、特に便利である。</para>

      <para>ソースファイルを探すときの探索パスは、次に示すように、GHCiのコマンド行で<option>-i</option>を使って指定することができる。</para>

<screen>ghci -i<replaceable>dir<subscript>1</subscript></replaceable>:...:<replaceable>dir<subscript>n</subscript></replaceable></screen>

      <para>あるいは、GHCiの中から<literal>:set</literal>コマンドを使って設定することもできる(<xref linkend="ghci-cmd-line-options"/>を見よ)<footnote><para>GHCiや<option>&ndash;&ndash;make</option>モードでは<option>-i</option>オプションは<emphasis>ソース</emphasis>ファイルの探索パスを指定するのに対し、標準の一括コンパイルモードでは<option>-i</option>オプションはインターフェースファイルの探索パスを指定することに注意。<xref linkend="search-path"/>を見よ。</para></footnote>。</para>

      <para>GHCiが上記のような方法で依存関係を追うことの帰結として、全てのモジュールにソースファイルがなければならない、というものがある。唯一の例外はパッケージ由来のモジュールで、これには<literal>Prelude</literal>や、<literal>IO</literal>、<literal>Complex</literal>といった標準ライブラリが含まれる。モジュールをロードしようとたときGHCiがソースファイルを見付けられなかった場合、たとえそのモジュールのオブジェクトファイルやインタフェースファイルがあったとしても、エラーメッセージが表示されるだろう。</para>
    </sect2>

    <sect2>
      <title>ソースコードの変更と再コンパイル</title>
      <indexterm><primary><literal>:reload</literal></primary></indexterm>

      <para>ソースコードに変更を加えて、GHCiに再コンパイルさせたいときは、<literal>:reload</literal>コマンドを使えば良い。プログラムは必要に応じて再コンパイルされる。このとき、GHCiは依存関係の変化がないモジュールを実際に再コンパイルするのを避けようと最善を尽くす。これは一括コンパイル時に再コンパイルを避ける機構(<xref linkend="recomp"/>を見よ)と同じである。</para>
    </sect2>
  </sect1>

  <sect1 id="ghci-compiled">
    <title>コンパイル済みコードをロードする</title>
    <indexterm><primary>compiled code</primary><secondary>in GHCi</secondary></indexterm>

    <para>HaskellのソースモジュールをGHCiにロードしたとき、それはふつうバイトコードに変換され、解釈実行器を使って実行される。しかし、解釈実行されるコードをコンパイル済みコードと共に実行することもできる。実際、GHCiは起動するとふつう<literal>base</literal>パッケージのコンパイル済みのものをロードする(そのなかに<literal>Purelude</literal>がある)。</para>

    <para>なぜコンパイル済みのコードを使う必要があるのだろうか。コンパイル済みコードは解釈実行されるコードに比べて大体10倍速いが、一方、生成するのに2倍の時間が掛かる(最適化が有効ならさらに長いかもしれない)のである。そのため、プログラムのあまり変更されない部分をコンパイルしておき、活発に開発されている部分には解釈実行器を使う、ということをするだけの価値がある。</para>

    <para><literal>:load</literal>でソースファイルをロードするとき、GHCiは対応するオブジェクトファイルを探し、可能ならソースコードの解釈実行よりも優先してそれを使う。例えば、A、B、C、Dという四つのモジュールからなるプログラムがあるとしよう。モジュールBとCはどちらもDのみをインポートしていて、AはBとCをインポートしている。</para>
<screen>
      A
     / \
    B   C
     \ /
      D
</screen>
    <para>Dをコンパイルして、その後プログラム全体をロードすると次のようになる。</para>
<screen>
Prelude> :! ghc -c D.hs
Prelude> :load A
Skipping  D                ( D.hs, D.o )
Compiling C                ( C.hs, interpreted )
Compiling B                ( B.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C, D.
*Main>
</screen>

    <para>コンパイラのメッセージから、Dの処理が省かれ、オブジェクトファイル<filename>D.o</filename>が使われたことが分かる。<literal>Skipping</literal><replaceable>module</replaceable>は、<replaceable>module</replaceable>のソースや依存関係が、最後にコンパイルされたときから変更されていないため、コンパイルが必要ないということを示している。</para>

    <para>いつでも、<literal>:show modules</literal>コマンドを使って、その時点でロードされているモジュールの一覧を表示することができる。</para>

<screen>
*Main> :show modules
D                ( D.hs, D.o )
C                ( C.hs, interpreted )
B                ( B.hs, interpreted )
A                ( A.hs, interpreted )
*Main></screen>

    <para>ここでDを編集(あるいは編集したふりをする。これにはUnixの<literal>touch</literal>コマンドが便利である)すると、コンパイラはオブジェクトファイルを使うことができなくなる。既に古くなっているかもしれないからである。</para>

<screen>
*Main> :! touch D.hs
*Main> :reload
Compiling D                ( D.hs, interpreted )
Skipping  C                ( C.hs, interpreted )
Skipping  B                ( B.hs, interpreted )
Skipping  A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C, D.
*Main> 
</screen>

    <para>Dがコンパイルされたが、この例ではDのソースは実際には変更されていないので、インタフェースは同じままであり、そのため再コンパイル検査器がA、B、Cを再コンパイルする必要がないと判断したことに注意。</para>

    <para>では他のモジュールをコンパイルしてみよう。</para>

<screen>
*Main> :! ghc -c C.hs
*Main> :load A
Compiling D                ( D.hs, interpreted )
Compiling C                ( C.hs, interpreted )
Compiling B                ( B.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C, D.
</screen>

    <para>Cのコンパイル済みの版が使われていない。これはどうしたことかというと、GHCではコンパイル済みのモジュールは別のコンパイル済みのモジュールにしか依存できないのである。この場合は、CがDに依存するが、Dにはオブジェクトファイルがないので、GHCiはCのオブジェクトファイルも利用しなかった。では、Dもコンパイルしてみよう。</para>

<screen>
*Main> :! ghc -c D.hs
*Main> :reload
Ok, modules loaded: A, B, C, D.
</screen>

    <para>なにも起こらない！これは新たな教訓である。新しくコンパイルされたモジュールは<literal>:reload</literal>では使われない。<literal>:load</literal>が必要である。</para>

<screen>
*Main> :load A
Skipping  D                ( D.hs, D.o )
Skipping  C                ( C.hs, C.o )
Compiling B                ( B.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C, D.
</screen>

    <para>ヒント: GHCはコンパイル済みの版が最新であることが確かな場合しかコンパイル済みオブジェクトファイルを使わないので、大きいプロジェクトを扱っているときは、ときどき<literal>ghc &ndash;&ndash;make</literal>を実行してプロジェクト全体をコンパイルし(例えば昼食を食べに行く前に　笑)、解釈実行器を使って作業を続けるというのが良い方法である。コードを変更すると、新しいモジュールは解釈実行されるが、プロジェクト中のその他の部分は変わらずコンパイル済みのものが使われる。</para>

  </sect1>

  <sect1>
    <title>プロンプトで対話的に評価する</title>

    <para>プロンプトに式を入力すると、GHCiは即座に評価して結果を印字する。
<screen>
Prelude> reverse "hello"
"olleh"
Prelude> 5+5
10
</screen>
</para>

<sect2><title>I/O動作とプロンプト</title>

<para>GHCiはプロンプトにおいて行うのは単なる式の評価だけではない。なんらかの<literal>a</literal>について<literal>IO a</literal>の型を持つものを入力すると、GHCiはそれをIO動作として<emphasis>実行</emphasis>するのである。
<screen>
Prelude> "hello"
"hello"
Prelude> putStrLn "hello"
hello
</screen>
さらに、次の場合には(そしてその場合に限り)、GHCiはIO動作の結果を印字する。
<itemizedlist>
  <listitem><para>結果の型が<literal>Show</literal>のインスタンスである。</para></listitem>
  <listitem><para>結果の型が<literal>()</literal>でない。</para></listitem>
</itemizedlist>
例えば、<literal>putStrLn :: String -> IO ()</literal>に注意すると、次のようになる。
<screen>
Prelude> putStrLn "hello"
hello
Prelude> do { putStrLn "hello"; return "yes" }
hello
"yes"
</screen>
</para></sect2>

    <sect2 id="ghci-stmts">
      <title>プロンプトで<literal>do</literal>記法を使う</title>
      <indexterm><primary>do-notation</primary><secondary>in GHCi</secondary></indexterm>
      <indexterm><primary>statements</primary><secondary>in GHCi</secondary></indexterm>
      
      <para>GHCiは実際には単なる式ではなく<firstterm>文</firstterm>を受け付ける。そのため、値や関数を名前に束縛して、後で式や文の中で使うことができる。</para>

      <para>GHCiプロンプトが受け付ける文の構文は、Haskellの<literal>do</literal>式における文の構文と全く同じである。ただし、こちらにはモナドの多重定義はない。プロンプトに入力される文は<literal>IO</literal>モナドの中になければならない。
<screen>
Prelude> x &lt;- return 42
42
Prelude> print x
42
Prelude>
</screen>
      <literal>x &lt;- return 42</literal>という文は、「<literal>return 42</literal>を<literal>IO</literal>モナドの中で実行し、結果を<literal>x</literal>に束縛する」という意味である。以降、<literal>x</literal>を文の中で使う(例えば、上でしたように、値を印字する)ことができるようになる。</para>

      <para>GHCiは次の場合には(そしてその場合に限り)、文の結果を印字する。
	<itemizedlist>
	  <listitem>
            <para>文が束縛ではないか、ただ一つの変数を束縛するモナド束縛(<literal>p &lt;- e</literal>)である。</para>
	  </listitem>
	  <listitem>
            <para>変数の型が多相的でなく、<literal>()</literal>でなく、<literal>Show</literal>のインスタンスである。</para>
	  </listitem>
	</itemizedlist>
      束縛結果を自動的に印字する機能は<option>:set -fno-print-bind-result</option>で抑制できる(束縛以外の式の結果を印字することは抑制されない)。<indexterm><primary><option>-fno-print-bind-result</option></primary></indexterm><indexterm><primary><option>-fprint-bind-result</option></primary></indexterm>これは、例えば、束縛の結果が印字のために完全に評価されるのを防ぐのに使うことができる。</para>

      <para>もちろん、非IOの式を<literal>let</literal>文を使って束縛することもできる。</para>
<screen>
Prelude> let x = 42
Prelude> x
42
Prelude>
</screen>
      <para>この二種類の束縛のもう一つの違いは、モナド束縛(<literal>p &lt;- e</literal>)が<emphasis>正格</emphasis>(<literal>e</literal>が評価される)のに対して、<literal>let</literal>形式では式がすぐには評価されないことである。</para>
<screen>
Prelude> let x = error "help!"
Prelude> print x
*** Exception: help!
Prelude>
</screen>

      <para>モナド束縛と違って、<literal>let</literal>束縛では束縛された値が自動的に印字されることがないことに注意。</para>

      <para>文を評価または実行している間に発生した例外は、GHCiのコマンド行インタフェースによって捕捉され、印字される(例外について詳しくは、ライブラリ説明書の<literal>Control.Exception</literal>を見よ)。</para>

      <para>束縛は、同じ名前の既存の束縛を覆い隠す。現在のモジュールの文脈でスコープにある実体も同様に覆い隠される。</para>

      <para>警告: プロンプトで導入された束縛は一時的なもので、次に<literal>:load</literal>か<literal>:reload</literal>コマンドが実行されるまでしか存在しない。これらのコマンドが実行されると、一時的な束縛は全て失われる。ただし、<literal>:module</literal>での文脈の変更では失われない。一時的な束縛が新しい場所に移動するだけである。</para>

      <para>ヒント: <literal>:show binding</literal>コマンドを使うと、その時点でスコープにある束縛の一覧を得ることができる。</para>

<screen>
Prelude> :show bindings
x :: Int
Prelude></screen>

      <para>ヒント: <literal>+t</literal>オプションを有効にすると、GHCiは文によって束縛された全ての変数の型を表示するようになる。例えば、次のようにである。</para>
      <indexterm><primary><literal>+t</literal></primary></indexterm>
<screen>
Prelude> :set +t
Prelude> let (x:xs) = [1..]
x :: Integer
xs :: [Integer]
</screen>

    </sect2>

    <sect2 id="ghci-scope">
      <title>プロンプトで実際にスコープにあるのは何か</title>

      <para>プロンプトに式を入力するとき、どの識別子や型がスコープにあるのだろうか。GHCiでは、式を評価する際の環境をどうやって構築するか、正確に指定することができる。単純な場合から始めよう。GHCiを開始すると、プロンプトは次のようになっている。</para>

<screen>Prelude></screen>

      <para>これは、<literal>Prelude</literal>モジュールの全てのものが現在スコープにあるということを示している。ここでファイルをGHCiにロードすると、プロンプトは次のように変わる。</para>

<screen>
Prelude> :load Main.hs
Compiling Main             ( Main.hs, interpreted )
*Main>
</screen>

      <para>新しいプロンプトは<literal>*Main</literal>であり、これは、入力される式が、<literal>Main</literal>モジュールのトップレベルの文脈で評価されるということである。<!-- 今ロードしたばかりの --><literal>Main</literal>モジュールのトップレベルでスコープにあるものは、全てプロンプトでもスコープにある。(<literal>Main</literal>が明示的に隠していない限り、これにはおそらく<literal>Prelude</literal>も含まれる)</para>

      <para><literal>*<replaceable>module</replaceable></literal>という構文は、プロンプトから入力される式に対して、<replaceable>module</replaceable>の完全なトップレベルスコープが使われるということを示している。<literal>*</literal>がない場合、そのモジュールがエクスポートしているものだけが可視である。</para>

      <para>扱えるのは単一のモジュールだけではない。GHCiは複数のモジュールのスコープを組み合わせることができ、このとき<literal>*</literal>が付く形式と<literal>*</literal>なしの形式を混合して用いることができる。GHCiはこれらのモジュールのスコープを全て組み合わせ、プロンプトのスコープとする。技術的な理由から、GHCiは解釈実行されるモジュールについてしか<literal>*</literal>形式をサポートしない。そのため、コンパイル済みモジュールは、それがエクスポートしたものでしかプロンプトのスコープに寄与できない。</para>

      <para>スコープは<literal>:module</literal>コマンドで操作できる。例えば、現在のスコープが<literal>Prelude</literal>なら、次のようにして、<literal>IO</literal>モジュールでエクスポートされたものをスコープに導入することができる。</para>

<screen>
Prelude> :module +IO
Prelude IO> hPutStrLn stdout "hello\n"
hello
Prelude IO>
</screen>

      <para>(注意: <literal>:module</literal>は<literal>:m</literal>に短縮できる)<literal>:module</literal>コマンドの完全な構文は次の通り。</para>

<screen>
:module <optional>+|-</optional> <optional>*</optional><replaceable>mod<subscript>1</subscript></replaceable> ... <optional>*</optional><replaceable>mod<subscript>n</subscript></replaceable>
</screen>

      <para><literal>+</literal>を使えばモジュールが現在のスコープに加えられ、<literal>-</literal>では削除される。<literal>+</literal>も<literal>-</literal>もない場合は、指定されたモジュール群がそのままで現在のスコープになる。この形式を使って、しかも<literal>Prelude</literal>を含めなかった場合、GHCiは<literal>Prelude</literal>が実は必要とされていると推定し、それを追加することに注意せよ。(<literal>Prelude</literal>が必要ない場合は、<literal>:m -Prelude</literal>で削除すれば良い)。</para>

      <para><literal>:load</literal>コマンドが実行されると、直近にロードされた「ターゲット」モジュールがスコープとして自動的に設定される。このとき、可能なら<literal>*</literal>形式が使われる。例えば、<literal>:load foo.hs bar.hs</literal>と入力したとき、<filename>bar.hs</filename>には<literal>Bar</literal>というモジュールがあるとすると、スコープは、<literal>Bar</literal>が解釈実行されているなら<literal>*Bar</literal>になり、<literal>Bar</literal>がコンパイル済みなら<literal>Prelude Bar</literal>になる。(GHCiは<literal>Prelude</literal>が指定されておらず、しかも<literal>*</literal>形式のモジュールが一つもないとき、自動的に<literal>Prelude</literal>を付け加える)</para>

      <para>複数のモジュールがスコープにあるとき、特に複数の<literal>*</literal>形式のモジュールがあるときは、名前の衝突が起こりやすい。Haskellでは、名前の衝突は曖昧な識別子が使われたときのみ報告されると定められており、GHCiもプロンプトで入力される式についてこれに倣っている。</para>

      <para>
        ヒント: GHCiはスコープにある名前についてタブ補完を行う。例えば、GHCiを起動して<literal>J&lt;tab&gt;</literal>と打つと、GHCiはそれを<literal>Just </literal>に展開する。
      </para>

      <sect3>
	<title>修飾名</title>

        <para>手間をすこし省くことができるように、GHCiのプロンプトは、全てのパッケージの全てのモジュールと、現在GHCiにロードされている全てのモジュールについて、暗黙の<literal>import qualified</literal>宣言があるかのように振る舞う。</para>

      </sect3>

      <sect3>
        <title><literal>:main</literal>コマンド</title>

        <para>
          プログラムがコンパイルされ実行されるとき、コマンド行引数にアクセスするために<literal>getArgs</literal>関数を使うことができる。しかし、ghciでテストをしているときは、コマンド行引数を単純に<literal>main</literal>関数の引数として渡すことはできない。<literal>main</literal>関数は直接には引数をとらないからである。
        </para>

        <para>
          その代わり、<literal>:main</literal>コマンドを使うことができる。これは、とにかくスコープにある<literal>main</literal>を、引数がコマンド行から渡されたのと同じようにして実行する。例えば、次のようにである。
        </para>

<screen>
Prelude> let main = System.Environment.getArgs >>= print
Prelude> :main foo bar
["foo","bar"]
</screen>

      </sect3>
    </sect2>
  

    <sect2>
      <title><literal>it</literal>という変数</title>
      <indexterm><primary><literal>it</literal></primary>
      </indexterm>
      
      <para>式(正確には束縛文でない文)がプロンプトに入力されると、GHCiはその値を暗黙のうちに変数<literal>it</literal>に束縛する。例えば、次のようにである。</para>
<screen>
Prelude> 1+2
3
Prelude> it * 2
6
</screen>
    <para>実際に何が起こっているかというと、GHCiは入力された式を型検査し、もし<literal>IO</literal>型でなければ、それを次のように変形するのである。式<replaceable>e</replaceable>は
<screen>
let it = <replaceable>e</replaceable>;
print it
</screen>
    になり、これがIO動作として実行される。</para>

    <para>そのため、元の式の型は<literal>Show</literal>のインスタンスでなければならない。そうでなければ、GHCiは次のように文句を言う。</para>

<screen>
Prelude&gt; id

&lt;interactive&gt;:1:0:
    No instance for (Show (a -&gt; a))
      arising from use of `print' at &lt;interactive&gt;:1:0-1
    Possible fix: add an instance declaration for (Show (a -> a))
    In the expression: print it
    In a 'do' expression: print it
</screen>

    <para>このエラーメッセージから、内部でどういう変換が起こっているかを少しうかがい知ることができる。</para>

      <para>式の型がなんらかの<literal>a</literal>について<literal>IO a</literal>である場合は、<literal>it</literal>は<literal>IO</literal>動作の結果(これの型は<literal>a</literal>である)に束縛される。例えば、以下。</para>
<screen>
Prelude> Time.getClockTime
Wed Mar 14 12:23:13 GMT 2001
Prelude> print it
Wed Mar 14 12:23:13 GMT 2001
</screen>

      <para>IO型の<replaceable>e</replaceable>についてなされる変換は、
<screen>
it &lt;- <replaceable>e</replaceable>
</screen>
      である。
      </para>

      <para>新しい式を評価するたびに<literal>it</literal>は新しい値で覆い隠され、<literal>it</literal>の古い値は失われることに注意。</para>
    </sect2>

    <sect2 id="extended-default-rules">
      <title>GHCiにおける型のデフォルト化</title>
    <indexterm><primary>Type default</primary></indexterm>
    <indexterm><primary><literal>Show</literal> class</primary></indexterm>
      <para>
      次のGHCiセッションを考えてみよう。
<programlisting>
  ghci> reverse []
</programlisting>
      GHCiは何をするべきか。厳密に言うと、このプログラムは曖昧である。<literal>show (reverse [])</literal>(ここでGHCi計算するのはこれである)の型は<literal>Show a =&gt; a</literal>であり<!-- 訳注 これは誤り-->、これをどのように表示するかは<literal>a</literal>の型に依存する。例えば、
<programlisting>
  ghci> (reverse []) :: String
  ""
  ghci> (reverse []) :: [Int]
  []
</programlisting>
    のようになる。しかし、利用者が型を指定しなければならないというのは面倒なので、GHCiはHaskellの型デフォルト化規則(Haskell 98 改訂レポートのセクション4.3.4)を以下のように拡張している。標準の規則では、個々の型変数<literal>a</literal>について制約の集まり<literal>(C1 a, C2 a, ..., Cn a)</literal>を考え、次の条件が満たされたとき、この型変数をデフォルト化する。
	<itemizedlist>
	    <listitem><para>型変数<literal>a</literal>が他のどの制約にも現れない。</para></listitem>
            <listitem><para><literal>Ci</literal>が全て標準のクラスである。</para></listitem>
            <listitem><para><literal>Ci</literal>のうち、少なくとも一つが数値クラスである。</para></listitem>
      </itemizedlist>
   GHCiのプロンプトでは、二番目と三番目の規則が次のように緩和されている。(相異点は強調書体で示した)
	<itemizedlist>
            <listitem><para><literal>Ci</literal>が<emphasis>全て</emphasis>単引数の型クラスである。</para></listitem>
            <listitem><para><literal>Ci</literal>のうち、少なくとも一つが数値クラスである<emphasis>か、
            <literal>Show</literal>であるか、<literal>Eq</literal>であるか、<literal>Ord</literal>である</emphasis>。</para></listitem>
      </itemizedlist>
   <literal>-XExtendedDefaultRules</literal>フラグを使うと、これと同じデフォルト化を通常のHaskellモジュールに対して有効にすることができる。
   </para>
    </sect2>
  </sect1>

  <sect1 id="ghci-invocation">
    <title>GHCiを起動する</title>
    <indexterm><primary>invoking</primary><secondary>GHCi</secondary></indexterm>
    <indexterm><primary><option>&ndash;&ndash;interactive</option></primary></indexterm>

    <para>GHCiは<literal>ghci</literal>または<literal>ghc &ndash;&ndash;interactive</literal>というコマンドで起動される。一つまたは複数のモジュールやファイル名をコマンド行から指定することもできる。そうすると、GHCiは、プロンプトで<literal>:load <replaceable>module</replaceable></literal>と入力されたときと同じように(<xref linkend="ghci-commands"/>を見よ)、指定されたモジュールやファイル(と、それらが依存するモジュール)をロードする。例えば、GHCiを起動して、プログラム(<literal>Main.hs</literal>に最上位モジュールがある)をロードするには、次のように打てば良い。</para>

<screen>
$ ghci Main.hs
</screen>

    <para>GHCが受け付けるコマンド行オプション(<xref linkend="using-ghc"/>を見よ)の大部分は対話的モードでも有効であり、そうでないオプションは大抵明らかである。例えば、GHCiはインタフェースファイルを生成しないので、インタフェースファイルの生成に関するオプションはなんの効果もない。</para>

    <sect2>
      <title>パッケージ</title>
      <indexterm><primary>packages</primary><secondary>with GHCi</secondary></indexterm>

      <para>大部分のパッケージ(<xref linkend="using-packages"/>を見よ)は追加のフラグを指定することなく利用可能であり、初めて必要になったときに自動的にロードされる。</para>

      <para>一方で、自動的にロードされないパッケージについては、<literal>-package</literal>フラグを使ってロードを依頼する必要がある。</para>

<screen>
$ ghci -package readline
   ___         ___ _
  / _ \ /\  /\/ __(_)
 / /_\// /_/ / /  | |      GHC Interactive, version 6.6, for Haskell 98.
/ /_\\/ __  / /___| |      http://www.haskell.org/ghc/
\____/\/ /_/\____/|_|      Type :? for help.

Loading package base ... linking ... done.
Loading package readline-1.0 ... linking ... done.
Prelude> 
</screen>

      <para>起動中のGHCiから新しいパッケージをロードするには、次のコマンドが使える。</para>

<screen>
Prelude> :set -package <replaceable>name</replaceable>
</screen>

      <para>ただし、これをするとロードされているモジュールが全て未ロードになり、<literal>Prelude</literal>に戻されることになるので注意。</para>
    </sect2>

    <sect2>
      <title>追加のライブラリ</title>
      <indexterm><primary>libraries</primary><secondary>with GHCi</secondary></indexterm>
      
      <para>追加のライブラリは、コマンド行から、通常の<literal>-l<replaceable>lib</replaceable></literal>オプションを使って指定することができる。(ここでいう<emphasis>ライブラリ</emphasis>とは、他言語のオブジェクトコードのライブラリのことである。Haskellソースのライブラリを使うことについては、<xref linkend="ghci-modules-filenames"/>を見よ)例えば、「m」ライブラリをロードするには、次のようにすれば良い。</para>

<screen>
$ ghci -lm
</screen>

      <para><literal>.so</literal>形式の共有ライブラリを使うシステムでは、実際にロードされるライブラリは<filename>lib<replaceable>lib</replaceable>.so</filename>である。GHCiは、ライブラリを探すとき、以下の場所をこの順で試す。</para>

      <itemizedlist>
	<listitem>
          <para><literal>-L<replaceable>path</replaceable></literal>コマンド行オプションで指定されたパス。</para>
	</listitem>
	<listitem>
          <para>システムの標準ライブラリ探索パス。これは、システムによっては、<literal>LD_LIBRARY_PATH</literal>環境変数を設定することで変更できる。</para>
	</listitem>
      </itemizedlist>

      <para><literal>.dll</literal>形式の共有ライブラリを使うシステムでは、実際にロードされるライブラリは<filename><replaceable>lib</replaceable>.dll</filename>である。この場合も、ライブラリが見付からなかった場合はGHCiはエラーを報告する。</para>

      <para>GHCiは単なるオブジェクトファイル(プラットフォームによって、<literal>.o</literal>か<literal>.obj</literal>である)をコマンド行からロードすることもできる。これには、オブジェクトファイルの名前をコマンド行に追加するだけで良い。</para>

      <para><option>-l</option>の順序は意味を持つ。あるライブラリは、それが依存するライブラリよりも<emphasis>前</emphasis>に言及されなければならない。(<xref linkend="options-linker"/>を見よ)</para>
    </sect2>

  </sect1>

  <sect1 id="ghci-commands">
    <title>GHCiのコマンド群</title>

    <para>GHCiのコマンドは全て「<literal>:</literal>」ではじまり、一つのコマンド名とそれに続く零個以上のパラメータから成る。コマンド名は短縮することができ、曖昧な場合はより一般的に使われるコマンドが優先される。</para>

    <variablelist>
      <varlistentry>
	<term>
          <literal>:add</literal> <replaceable>module</replaceable> ...
          <indexterm><primary><literal>:add</literal></primary></indexterm>
        </term>
	<listitem>
          <para><replaceable>module</replaceable>を現在の<firstterm>ターゲット集合</firstterm>に追加し、リロードを行う。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:browse</literal> <optional><literal>*</literal></optional><replaceable>module</replaceable> ...
          <indexterm><primary><literal>:browse</literal></primary></indexterm>
        </term>
	<listitem>
          <para><replaceable>module</replaceable>で定義されている識別子を表示する。<replaceable>module</replaceable>は、GHCiにロードされているか、パッケージの要素でなければならない。<literal>*</literal>記号がモジュール名の前に置かれたときは、<replaceable>module</replaceable>で定義された<emphasis>全ての</emphasis>識別子が表示される。そうでない場合、一覧は<replaceable>module</replaceable>がエクスポートしたものに限定される。<literal>*</literal>形式は解釈実行されているモジュールに対してのみ有効である。コンパイル済みモジュール(パッケージ由来のモジュールも含む)に対しては非<literal>*</literal>形式の<literal>:browse</literal>のみが利用可能である。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:cd</literal> <replaceable>dir</replaceable>
          <indexterm><primary><literal>:cd</literal></primary></indexterm>
        </term>
	<listitem>
          <para>作業ディレクトリを<replaceable>dir</replaceable>に変更する。<replaceable>dir</replaceable>の先頭が「<literal>&tilde;</literal>」記号の場合、それは<literal>HOME</literal>環境変数の内容で置き換えられる。</para>

          <para>注意: ディレクトリを変更すると、ロードされているモジュールは全て未ロードになる。これは、探索パスがふつう相対ディレクトリを使って表されており、また、セッションの途中で探索パスを変更することがサポートされていないためである。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:def</literal> <replaceable>name</replaceable> <replaceable>expr</replaceable>
          <indexterm><primary><literal>:def</literal></primary></indexterm>
        </term>
	<listitem>
	  <para>コマンド<literal>:def</literal> <replaceable>name</replaceable> <replaceable>expr</replaceable>は、新しいGHCiコマンド<literal>:<replaceable>name</replaceable></literal>を、Haskellの式<replaceable>expr</replaceable>で実装されたものとして定義する。式の型は<literal>String -&gt; IO String</literal>でなければならない。<literal>:<replaceable>name</replaceable> <replaceable>args</replaceable></literal>がプロンプトに入力されると、GHCiは式<literal>(<replaceable>name</replaceable> <replaceable>args</replaceable>)</literal>を走らせ、結果の<literal>String</literal>を受け取り、それをコマンドの列として再びGHCiに入力する。結果においては、隣り合うコマンドは「<literal>\n</literal>」で区切られていなければならない。</para>

          <para>これは少々ややこしいので、いくつか例を挙げる。まず、次に示す新しいGHCiコマンドは、引数を取らず、結果を生成せず、単に現在の日時を出力するだけのものである。</para>

<screen>
Prelude> let date _ = Time.getClockTime >>= print >> return ""
Prelude> :def date date
Prelude> :date
Fri Mar 23 15:16:40 GMT 2001
</screen>

          <para>引数を取るコマンドの例を示す。これは<literal>:cd</literal>の再実装である。</para>

<screen>
Prelude> let mycd d = Directory.setCurrentDirectory d >> return ""
Prelude> :def mycd mycd
Prelude> :mycd ..
</screen>

          <para>あるいは、現在のディレクトリで「<literal>ghc &ndash;&ndash;make Main</literal>」を起動する単純な方法を定義することもできる。</para>

<screen>
Prelude> :def make (\_ -> return ":! ghc &ndash;&ndash;make Main")
</screen>

          <para>GHCiへの入力をファイルから読み込むコマンドを定義することもできる。これは、あらかじめ決まった束縛を繰り返しGHCiセッションにロードしたいというときに便利かもしれない。</para>

<screen>
Prelude> :def . readFile
Prelude> :. cmds.ghci
</screen>

          <para>このコマンドの名前は<literal>:.</literal>であるが、これは「<literal>.</literal>」(同じことをするUnixシェルのコマンド)のアナロジーである。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:edit <optional><replaceable>file</replaceable></optional></literal>
          <indexterm><primary><literal>:edit</literal></primary></indexterm>
        </term>
	<listitem>
          <para>エディタを開いて、<replaceable>file</replaceable>、それが省略されたときは直近にロードされたモジュールを編集する。起動されるエディタは<literal>EDITOR</literal>環境変数から採られるか、<literal>EDITOR</literal>が設定されていないときはシステムのデフォルトエディタが使われる。使われるエディタは<literal>:set editor</literal>で変更することができる。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:help</literal>
          <indexterm><primary><literal>:help</literal></primary></indexterm>
        </term>
	<term>
          <literal>:?</literal>
          <indexterm><primary><literal>:?</literal></primary></indexterm>
        </term>
	<listitem>
          <para>利用可能なコマンドの一覧を表示する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:info</literal> <replaceable>name</replaceable> ...
          <indexterm><primary><literal>:info</literal></primary></indexterm>
        </term>
	<listitem>
          <para>与えられた名前についての情報を表示する。例えば、もし<replaceable>name</replaceable>がクラスなら、クラスメソッドとその型が印字される。もし<replaceable>name</replaceable>が型構築子なら、その定義が印字される。もし<replaceable>name</replaceable>が関数なら、その型が印字される。<replaceable>name</replaceable>がソースファイルからロードされたものであった場合、GHCiはその定義のソースコード中の位置も表示する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:load</literal> <replaceable>module</replaceable> ...
          <indexterm><primary><literal>:load</literal></primary></indexterm>
        </term>
	<listitem>
          <para>指定された<replaceable>module</replaceable>とそれが依存するモジュールすべてを再帰的にロードする。ここで、個々の<replaceable>module</replaceable>はモジュール名またはファイル名でなければならない。また、パッケージ中のモジュールの名前であってはいけない。</para>

          <para>以前にロードされていたモジュールは、パッケージ中のものを除いて、忘れ去られる。この新しいモジュールの集合を<firstterm>ターゲット集合</firstterm>と呼ぶ。<literal>:load</literal>を引数なしで使うと、ロードされているモジュールや束縛を全て未ロードにできることに注意。</para>

          <para><literal>:load</literal>コマンドの後、以下のものが文脈として設定される。</para>

	  <itemizedlist>
	    <listitem>
              <para><replaceable>module</replaceable>が成功裡にロードされたなら、<replaceable>module</replaceable>。</para>
	    </listitem>
	    <listitem>
              <para>そうでないとき、今回の<literal>:load</literal>でロードされたモジュールがあるなら、最後に成功裡にロードされたモジュール。</para>
	    </listitem>
	    <listitem>
	      <para>そうでなければ、<literal>Prelude</literal>。</para>
	    </listitem>
	  </itemizedlist>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:main <replaceable>arg<subscript>1</subscript></replaceable> ... <replaceable>arg<subscript>n</subscript></replaceable></literal>
          <indexterm><primary><literal>:main</literal></primary></indexterm>
        </term>
        <listitem>
          <para>
            プログラムがコンパイルされ実行されるとき、コマンド行引数にアクセスするために<literal>getArgs</literal>関数を使うことができる。しかし、ghciでテストをしているときは、これらの引数を単純に<literal>main</literal>関数の引数として渡すことはできない。<literal>main</literal>関数は直接には引数をとらないからである。
          </para>

          <para>
            その代わり、<literal>:main</literal>コマンドを使うことができる。これは、とにかくスコープにある<literal>main</literal>を、引数がコマンド行から渡されたのと同じようにして実行する。例えば、次のようにである。
          </para>

<screen>
Prelude> let main = System.Environment.getArgs >>= print
Prelude> :main foo bar
["foo","bar"]
</screen>

        </listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:module <optional>+|-</optional> <optional>*</optional><replaceable>mod<subscript>1</subscript></replaceable> ... <optional>*</optional><replaceable>mod<subscript>n</subscript></replaceable></literal>
          <indexterm><primary><literal>:module</literal></primary></indexterm>
        </term>
	<listitem>
          <para>プロンプトに入力される文のための文脈を設定または改変する。詳しくは<xref linkend="ghci-scope"/>を見よ。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:quit</literal>
          <indexterm><primary><literal>:quit</literal></primary></indexterm>
        </term>
	<listitem>
          <para>GHCiを終了する。プロンプトでCtrl-Dを打つことでも終了できる。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:reload</literal>
          <indexterm><primary><literal>:reload</literal></primary></indexterm>
        </term>
	<listitem>
          <para>現在のターゲット集合とそれらが依存するモジュールのうち、変更のあったものがあれば、ターゲット集合を再ロードしようと試みる。結果として、新しいモジュールがロードされたり、ターゲットから間接的に必要とされなくなったモジュールが外されたりするかもしれないことに注意せよ。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:set</literal> <optional><replaceable>option</replaceable>...</optional>
          <indexterm><primary><literal>:set</literal></primary></indexterm>
        </term>
	<listitem>
          <para>色々なオプションを設定する。利用可能なオプションの一覧は、<xref linkend="ghci-set"/>を見よ。<literal>:set</literal>コマンド自体は、どのオプションが現在有効になっているか表示する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:set</literal> <literal>args</literal> <replaceable>arg</replaceable> ...
          <indexterm><primary><literal>:set args</literal></primary></indexterm>
        </term>
	<listitem>
          <para>プログラムが<literal>System.getArgs</literal><indexterm><primary>getArgs</primary></indexterm>を呼んだときに返される引数のリストを設定する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
           <literal>:set</literal> <literal>editor</literal> <replaceable>cmd</replaceable>
        </term>
	<listitem>
          <para><literal>:edit</literal>コマンドで使われるエディタを<replaceable>cmd</replaceable>にする。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
	<term>
           <literal>:set</literal> <literal>prog</literal> <replaceable>prog</replaceable>
           <indexterm><primary><literal>:set prog</literal></primary></indexterm>
        </term>
	<listitem>
          <para>プログラムが<literal>System.getProgName</literal><indexterm><primary>getProgName</primary></indexterm>を呼んだときに返される文字列を設定する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
           <literal>:set</literal> <literal>prompt</literal> <replaceable>prompt</replaceable>
        </term>
	<listitem>
          <para>GHCiのプロンプトとして使われる文字列を設定する。<replaceable>prompt</replaceable>の中では、<literal>%s</literal>という並びは現在スコープにあるモジュールの名前に置き換えられ、<literal>%%</literal>は<literal>%</literal>に置き換えられる。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:show bindings</literal>
          <indexterm><primary><literal>:show bindings</literal></primary></indexterm>
        </term>
	<listitem>
          <para>プロンプトで導入された束縛と、その型を表示する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:show modules</literal>
          <indexterm><primary><literal>:show modules</literal></primary></indexterm>
        </term>
	<listitem>
          <para>現在ロードされているモジュールの一覧を表示する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
	  <literal>:ctags</literal> <optional><replaceable>filename</replaceable></optional>
	  <literal>:etags</literal> <optional><replaceable>filename</replaceable></optional>
	  <indexterm><primary><literal>:etags</literal></primary>
	  </indexterm>
	  <indexterm><primary><literal>:etags</literal></primary>
	  </indexterm>
	</term>
	<listitem>
          <para>Vi風のエディタ用(<literal>:ctags</literal>)またはEmacs風エディタ用(<literal>:etags</literal>)のタグファイルを生成する。ファイル名が指定されなかった場合は、それぞれデフォルトの<filename>tags</filename>または<filename>TAGS</filename>が使われる。ロードされているモジュール内の全ての関数、構築子、型のタグが作られる。これらのコマンドが働くには、全てのモジュールが解釈実行されていなければならない。</para>
          <para><xref linkend="hasktags"/>も見よ。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
         <literal>:type</literal> <replaceable>expression</replaceable>
         <indexterm><primary><literal>:type</literal></primary></indexterm>
        </term>
	<listitem>
          <para><replaceable>expression</replaceable>の型を推論し、印字する。多相型には明示的な全称量化が加えられる。推論に際して、単相性制限は適用されない。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:kind</literal> <replaceable>type</replaceable>
          <indexterm><primary><literal>:kind</literal></primary></indexterm>
        </term>
	<listitem>
          <para><replaceable>type</replaceable>の類を推論し、印字する。<replaceable>type</replaceable>は任意の型式で、<literal>Either Int</literal>のような型構築子の部分適用であっても構わない。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:undef</literal> <replaceable>name</replaceable>
          <indexterm><primary><literal>:undef</literal></primary></indexterm>
        </term>
	<listitem>
          <para>利用者定義のコマンド<replaceable>name</replaceable>を未定義にする。(上の<literal>:def</literal>を見よ)</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:unset</literal> <replaceable>option</replaceable>...
          <indexterm><primary><literal>:unset</literal></primary></indexterm>
        </term>
	<listitem>
          <para>ある種のオプションを無効にする。利用可能なオプションの一覧は、<xref linkend="ghci-set"/>を見よ。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:!</literal> <replaceable>command</replaceable>...
          <indexterm><primary><literal>:!</literal></primary></indexterm>
          <indexterm><primary>shell commands</primary><secondary>in GHCi</secondary></indexterm>
        </term>
	<listitem>
          <para>シェルのコマンド<replaceable>command</replaceable>を実行する。</para>
	</listitem>
      </varlistentry>

    </variablelist>
  </sect1>

  <sect1 id="ghci-set">
    <title><literal>:set</literal>コマンド</title>
    <indexterm><primary><literal>:set</literal></primary></indexterm>

    <para><literal>:set</literal>コマンドでは二系統のオプションを設定できる。「<literal>+</literal>」で始まるGHCiオプションと「-」で始まる「コマンド行」オプションである。</para>

    <para>注意: 現在のところ、<literal>:set</literal>コマンドは引数における引用符の使用を一切サポートしていない。引用符は削除されず、複数の単語を一つにまとめるのに使うこともできない。例えば、<literal>:set -DFOO='BAR BAZ'</literal>は期待した通りには動かないだろう。</para>

    <sect2>
      <title>GHCiオプション</title>
      <indexterm><primary>options</primary><secondary>GHCi</secondary>
      </indexterm>

      <para>GHCiオプションは、<literal>:set</literal>で有効化、
      <literal>:unset</literal>で無効化できる。</para>

      <para>利用できるGHCiオプションは以下のものである。</para>

      <variablelist>
	<varlistentry>
	  <term>
            <literal>+r</literal>
            <indexterm><primary><literal>+r</literal></primary></indexterm>
            <indexterm><primary>CAFs</primary><secondary>in GHCi</secondary></indexterm>
            <indexterm><primary>Constant Applicative Form</primary><see>CAFs</see></indexterm>
          </term>
	  <listitem>
            <para>通常、ロードされたモジュールにあるトップレベルの式(CAF(Constant Applicative Form)、あるいは定作用形とも呼ばれる)を評価した結果は、複数回のプロンプトでの評価をまたがって保持される。<literal>+r</literal>を有効にすると、トップレベルの式の評価結果はすべて、一回の評価が終わるごとに捨てられるようになる(それでも一回の評価の<emphasis>間は</emphasis>保持される)。</para>
	  
            <para>このオプションは、評価済みのトップレベル式が大量のメモリを消費するときや、再現性のある実行性能の計測をしたいときに有用かもしれない。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
            <literal>+s</literal>
            <indexterm><primary><literal>+s</literal></primary></indexterm>
          </term>
	  <listitem>
            <para>一つ式を評価するごとに、経過時間や確保されたバイト数などの統計情報を表示する。注意: 確保されたバイト数はGC毎に計算されるので、これは記憶領域管理器の確保領域の大きさ程度の正確さしかない。そういうわけで、GCが起こらなかった場合、値として0が表示されるかもしれない。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
            <literal>+t</literal>
            <indexterm><primary><literal>+t</literal></primary></indexterm>
          </term>
	  <listitem>
            <para>文がプロンプトに入力されたとき、束縛された変数それぞれの型を表示する。入力されたのが単一の式なら、束縛されるのは変数「<literal>it</literal>」だけである。</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="ghci-cmd-line-options">
      <title>GHCiからGHCのコマンド行オプションを設定する</title>

      <para>通常のGHCのコマンド行オプションを<literal>:set</literal>を使って設定することもできる。例えば、<option>-fglasgow-exts</option>を有効にするには、次のように入力すれば良い。</para>

<screen>
Prelude> :set -fglasgow-exts
</screen>
      
      <para>GHCのコマンド行オプションのうち、<firstterm>動的な</firstterm>オプション(<xref linkend="flag-reference"/>の表を見よ)として設計されているものは全て、<literal>:set</literal>を使って有効にすることができる。オプションを無効にするには、逆の効果を持つオプションを有効にすれば良い。</para><indexterm><primary>dynamic</primary><secondary>options</secondary></indexterm>

<screen>
Prelude> :set -fno-glasgow-exts
</screen>

      <para><xref linkend="flag-reference"/>には、可能なオプション全てについて逆の効果を持つオプションが記されている。</para>

      <para>ある種の静的なオプション(特に、<option>-package</option>、<option>-I</option>、<option>-i</option>、<option>-l</option>)も使えるが、次に再ロードするまで効果を発揮しないものもある。</para>
      <indexterm><primary>static</primary><secondary>options</secondary></indexterm>
    </sect2>
  </sect1>

  <sect1 id="ghci-dot-files">
    <title><filename>.ghci</filename>ファイル</title>
    <indexterm><primary><filename>.ghci</filename></primary><secondary>file</secondary>
    </indexterm>
    <indexterm><primary>startup</primary><secondary>files, GHCi</secondary>
    </indexterm>

    <para>GHCiは、開始するとき、常に<filename>$HOME/.ghci</filename>、次に<filename>./.ghci</filename>を読み、そこに書かれているコマンドを実行する。</para>

    <para>ホームディレクトリの<filename>.ghci</filename>は、あなたのお気に入りのオプション(例えば<literal>:set +s</literal>)を有効にしたり、便利なマクロを定義したりするのに適している。また、<filename>.ghci</filename>をHaskellプロジェクトのディレクトリに置いて、プロジェクトで使われるオプションを設定するようにしておくと、GHCiを立ち上げるたびにそれを打ち込まなくて済むので便利である。例えば、プロジェクトがGHC拡張とCPPを使い、ソースファイルがA、B、Cという三つのサブディレクトリに置かれているなら、次の数行を<filename>.ghci</filename>に置くことができる。</para>

<screen>
:set -fglasgow-exts -cpp
:set -iA:B:C
</screen>

    <para>(厳密には<option>-i</option>フラグは静的オプションであるが、このように<literal>:set</literal>しても動くことに注意。ただし、この変更は、次に<literal>:load</literal>が実行されるまで効果を発揮しない。)</para>

    <para><filename>.ghci</filename>ファイルが読まれるかどうかを制御する二つのコマンド行オプションがある。</para>

    <variablelist>
      <varlistentry>
	<term>
          <option>-ignore-dot-ghci</option>
          <indexterm><primary><option>-ignore-dot-ghci</option></primary></indexterm>
        </term>
	<listitem>
          <para>開始時に、<filename>./.ghci</filename>も<filename>$HOME/.ghci</filename>も読まない。</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>
          <option>-read-dot-ghci</option>
          <indexterm><primary><option>-read-dot-ghci</option></primary></indexterm>
        </term>
	<listitem>
          <para><filename>.ghci</filename>と<filename>$HOME/.ghci</filename>を読む。通常これがデフォルトであるが、<option>-read-dot-ghci</option>は前に指定された<option>-ignore-dot-ghci</option>を上書きするのに使うことができる。</para>
	</listitem>
      </varlistentry>
    </variablelist>

  </sect1>

  <sect1 id="ghci-faq">
    <title>FAQと注意事項</title>
    
    <variablelist>
      <varlistentry>
        <term>インタプリタがforeign export宣言のあるモジュールをロードできません！</term>
	<listitem>
          <para>残念ながらその通りである。それはまだ実装されていない。問題のあるモジュールは手でコンパイルしてからGHCiにロードしてほしい。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          GHCiで<literal>-O</literal>がうまく働きません！
          <indexterm><primary><option>-O</option></primary></indexterm>
         </term>
	<listitem>
          <para>技術的な理由から、バイトコードコンパイラが特定の最適化過程とうまく相互作用しないので、解釈実行器を使うときは最適化が無効にしてある。これは大きな問題ではない。高速に実行されるべきコードをコンパイルしておくことで、最適化つきで解釈実行するよりもずっと速く実行できる。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term>非ボックス化された組がGHCiで使えない</term>
	<listitem>
          <para>その通り。しかし、非ボックス化された組を使うモジュールをコンパイルして、それをGHCiにロードするということは常にできる。(ちなみに、上記の、<literal>-O</literal>がGHCiで使えないというのは、バイトコードコンパイラが非ボックス化された組を扱えないからである)</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term>GHCiが入力を待っている間、並列スレッドが走りつづけてくれない。</term>
	<listitem>
          <para>GHCiが<option>-threaded</option>スイッチを有効(デフォルト)にしてコンパイルされている限り、問題はないはずである。インストールしたGHCの供給元に相談してほしい。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>getContents</literal>を使った後、<literal>:load</literal>か<literal>:reload</literal>するまで<literal>stdin</literal>が使えない。</term>

	<listitem>
          <para>それは<literal>getContents</literal>の定義通りの振る舞いである。<literal>getContents</literal>はハンドルを<firstterm>セミクローズ</firstterm>という状態にするが、その状態ではいかなるIO操作も禁止される。計算と計算の間でIOの状態は保持されるので、次に<literal>:load</literal>か<literal>:reload</literal>コマンドが実行されるまでセミクローズ状態が続く。</para>

          <para><literal>:set +r</literal>というコマンドで<literal>stdin</literal>が毎回元の状態に復元されるようにすることができる。これがうまく行くのは、<literal>stdin</literal>が単なるトップレベルの式で、他のトップレベルの式(CAF)と同様の方法で未評価の状態に戻すことができるからである。</para>

	</listitem>
      </varlistentry>

      <varlistentry>
       <term>WindowsのGHCiで計算を中断するのにCtrl-Cが使えない。</term>
        <listitem>
          <para><xref linkend="ghci-windows"/>を参照。</para>
        </listitem>
      </varlistentry>

    </variablelist>
  </sect1>

</chapter>

<!-- Emacs stuff:
     ;;; Local Variables: ***
     ;;; mode: xml ***
     ;;; sgml-parent-document: ("users_guide.xml" "book" "chapter") ***
     ;;; End: ***
 -->
